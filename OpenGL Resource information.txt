



When you use a vertex array pointer command with buffer objects, the data stored in the buffer object must meet alignment requirements as
determined by the type parameter. GLfloat data is typically aligned on 4-byte boundaries, for example. If your application calls 
glVertexPointer () with the type parameter set to GL_FLOAT, each float element stored in the corresponding buffer object must lie on a 
4-byte boundary.


glDrawElements ()— This command renders a single OpenGL primitive with vertices and vertex data specified by vertex array indices.

glDrawRangeElements ()— This optimized form of glDrawElements () restricts selected vertex data to a specified range of index values.

glMultiDrawElements ()— This command renders multiple OpenGL primitives of the same type. It, too, uses indices to obtain vertex data from vertex arrays.




2.3.3 Smooth and Flat Shading
To simulate a smooth surface, OpenGL interpolates vertex colors during rasterization. To simulate a flat or faceted surface, change the
 default shade model from GL_SMOOTH to GL_FLAT by calling glShadeModel ( GL_FLAT ).

void glShadeModel( GLenum mode );


To determine the color of a primitive in flat shade mode, OpenGL uses the color of the vertex that completes the primitive. For GL_POINTS, 
this is simply the color of the vertex. For all line primitives (GL_LINES, GL_LINE_STRIP, and GL_LINE_LOOP), this is the color of the second vertex in a line segment.


void glPolygonMode( GLenum face, GLenum mode );

Specifies the rendering style for filled primitives. mode is GL_POINT, GL_LINE, or GL_FILL; and face must be GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK to specify whether 
mode applies to front- or back-facing primitives, or both.




Set up your tripod and pointing the camera at the scene (viewing transformation). 
Arrange the scene to be photographed into the desired composition (modeling transformation). 
Choose a camera lens or adjust the zoom (projection transformation). 
Determine how large you want the final photograph to be - for example, you might want it enlarged (viewport transformation).

https://computergraphics.stackexchange.com/questions/5895/what-is-an-opengl-vao-in-a-nutshell
you MUST bind the VBO's under a VAO to get rendering output, if you just bind the VAO you won't get outpt. That's not true.
 You can bind dummy VAO without attached VBOs and still dispatch drawcall. – narthex Nov 20 '

https://www.opengl.org/archives/resources/faq/technical/viewing.htm
gluLookAt(camera[0], camera[1], camera[2], /* look from camera XYZ */ 0, 0, 0, /* look at the origin */ 0, 1, 0); /* positive Y up vector */ glRotatef(orbitDegrees, 0.f, 1.f, 0.f);/* orbit the Y axis */ /* ...where orbitDegrees is derived from mouse motion */ glCallList(SCENE); /* draw the scene */




 GLenum glCheckFramebufferStatus(	GLenum target);
 
 void glDrawArrays(	GLenum mode,
 	GLint first,
 	GLsizei count);


	C Specification
void glVertexAttribPointer(	GLuint index,
 	GLint size,
 	GLenum type,
 	GLboolean normalized,
 	GLsizei stride,
 	const GLvoid * pointer);
 

 

//		glViewport(0,0,640,480);
//GLuint Vert_Shader_Id = 0,
//	   Frag_Shader_Id = 0,
//	   Shader_Program_Id = 0;
 //
 //                 // GL_VERTEX_SHADER 0x8B31
////		Load_Shader(0x8B31, VERTEX_SHADER  , &Vert_Shader_Id);
//		          //GL_FRAGMENT_SHADER 0x8B30
//		Load_Shader(0x8B30,FRAGMENT_SHADER  , &Frag_Shader_Id);
//		Shader_Program_Id = glCreateProgram();
//		glAttachShader(Shader_Program_Id, Vert_Shader_Id);
//		glAttachShader(Shader_Program_Id, Frag_Shader_Id);
//		Print(Vert_Shader_Id);
//		Print(Frag_Shader_Id);
 //

//glClear(.0,.3,.8,1.0);


//https://www.3dgep.com/rendering-primitives-with-opengl/

https://www.youtube.com/watch?v=IXxc9yNBpuo





// USE THIS TO MAKE A FPS Getter and Setters 
//glfwSwapBuffers(window);
//glfwSwapInterval(1);


LEFT OVER TEST MAIN() FROM 3D


bool InitGL__();
void RenderScene5(); 
 
#define SCREENWIDTH 640
#define SCREENHEIGHT 480

// 3-component floating-point value.

float angle;float translate,scale =1;

void Display(){  
  // glMatrixMode(GL_PROJECTION);     // To operate on Model-View matrix
  // glLoadIdentity();               // Reset the model-view matrix
  //    glTranslatef(-0.5f, 0.4f, 0.0f);    // Translate
  // glRotatef(angle, 0.0f, 1.0f, 0.0f); // rotate by angle in degrees
 

    glClear(GL_COLOR_BUFFER_BIT);   // Clear the color buffer
   glMatrixMode(GL_MODELVIEW);     // To operate on Model-View matrix
   glLoadIdentity();               // Reset the model-view matrix
 
   glPushMatrix();                     // Save model-view matrix setting

   glRotatef(angle, 0.0f, 1.0f, 0.0f); // rotate by angle in degrees
   glTranslatef(-0.5f, 0.4f, 0.0f);    // Translate
   glBegin(GL_QUADS);                  // Each set of 4 vertices form a quad
      glColor3f(1.0f, 0.0f, 0.0f);     // Red
      glVertex2f(-0.3f, -0.3f);
      glVertex2f( 0.3f, -0.3f);
      glVertex2f( 0.3f,  0.3f);
      glVertex2f(-0.3f,  0.3f);
   glEnd();
   glPopMatrix();                      // Restore the model-view matrix
 
   glPushMatrix();                     // Save model-view matrix setting
   glTranslatef(-0.4f, -0.3f, 0.0f);   // Translate
   glRotatef(angle, 0.0f, 0.0f, 1.0f); // rotate by angle in degrees
   glBegin(GL_QUADS);
      glColor3f(0.0f, 1.0f, 0.0f); // Green
      glVertex2f(-0.3f, -0.3f);
      glVertex2f( 0.3f, -0.3f);
      glVertex2f( 0.3f,  0.3f);
      glVertex2f(-0.3f,  0.3f);
   glEnd();
   glPopMatrix();                      // Restore the model-view matrix
 
   glPushMatrix();                     // Save model-view matrix setting
   glTranslatef(-0.7f, -0.5f, 0.0f);   // Translate
   glRotatef(angle, 0.0f, 0.0f, 1.0f); // rotate by angle in degrees
   glBegin(GL_QUADS);
      glColor3f(0.2f, 0.2f, 0.2f); // Dark Gray
      glVertex2f(-0.2f, -0.2f);
      glColor3f(1.0f, 1.0f, 1.0f); // White
      glVertex2f( 0.2f, -0.2f);
      glColor3f(0.2f, 0.2f, 0.2f); // Dark Gray
      glVertex2f( 0.2f,  0.2f);
      glColor3f(1.0f, 1.0f, 1.0f); // White
      glVertex2f(-0.2f,  0.2f);
   glEnd();
   glPopMatrix();                      // Restore the model-view matrix
 
   glPushMatrix();                     // Save model-view matrix setting
   glTranslatef(0.4f, -0.3f, 0.0f);    // Translate
   glRotatef(angle, 0.0f, 0.0f, 1.0f); // rotate by angle in degrees
   glBegin(GL_TRIANGLES);
      glColor3f(0.0f, 0.0f, 1.0f); // Blue
      glVertex2f(-0.3f, -0.2f);
      glVertex2f( 0.3f, -0.2f);
      glVertex2f( 0.0f,  0.3f);
   glEnd();
   glPopMatrix();                      // Restore the model-view matrix
 
   glPushMatrix();                     // Save model-view matrix setting
   glTranslatef(0.6f, -0.6f, 0.0f);    // Translate
   glRotatef(180.0f + angle, 0.0f, 0.0f, 1.0f); // Rotate 180+angle degree
   glBegin(GL_TRIANGLES);
      glColor3f(1.0f, 0.0f, 0.0f); // Red
      glVertex2f(-0.3f, -0.2f);
      glColor3f(0.0f, 1.0f, 0.0f); // Green
      glVertex2f( 0.3f, -0.2f);
      glColor3f(0.0f, 0.0f, 1.0f); // Blue
      glVertex2f( 0.0f,  0.3f);
   glEnd();
   glPopMatrix();                      // Restore the model-view matrix
 
   glPushMatrix();                     // Save model-view matrix setting
   glTranslatef(0.5f, 0.4f, 0.0f);     // Translate
   glRotatef(angle, 0.0f, 0.0f, 1.0f); // rotate by angle in degrees
   glBegin(GL_POLYGON);
      glColor3f(1.0f, 1.0f, 0.0f); // Yellow
      glVertex2f(-0.1f, -0.2f);
      glVertex2f( 0.1f, -0.2f);
      glVertex2f( 0.2f,  0.0f);
      glVertex2f( 0.1f,  0.2f);
      glVertex2f(-0.1f,  0.2f);
      glVertex2f(-0.2f,  0.0f);
   glEnd();
   glPopMatrix();                      // Restore the model-view matrix
 
   //glutSwapBuffers();   // Double buffered - swap the front and back buffers
 
   // Change the rotational angle after each display()
   angle += 0.2f;
}

void Reshape(GLsizei width, GLsizei height) {  // GLsizei for non-negative integer
   // Compute aspect ratio of the new window
   if (height == 0) height = 1;                // To prevent divide by 0
   GLfloat aspect = (GLfloat)width / (GLfloat)height;
 
   // Set the viewport to cover the new window
   glViewport(0, 0, width, height);
 
   // Set the aspect ratio of the clipping area to match the viewport
   glMatrixMode(GL_PROJECTION);  // To operate on the Projection matrix
   glLoadIdentity();             // Reset the projection matrix
   if (width >= height) {
     // aspect >= 1, set the height from -1 to 1, with larger width
      gluOrtho2D(-1.0 * aspect, 1.0 * aspect, -1.0, 1.0);
   } else {
      // aspect < 1, set the width to -1 to 1, with larger height
     gluOrtho2D(-1.0, 1.0, -1.0 / aspect, 1.0 / aspect);
   }
}


int main( int argc, char* args[] )
{
    
    //Initialize FreeGLUT
    glutInit( &argc, args );
     //glutInitContextVersion( 2, 1 );
//    GLuint id =  glCreateShader();
//Load_Shader(GL_FRAGMENT_SHADER ,FRAGMENT_SHADER_1 ,&id );

   glewExperimental = GL_TRUE;
        if (!glfwInit())return -1;
        Window Main(0,0,640, 480, "Hello World");

         
        GLenum GlewInitResult = glewInit() ;
        if ((GlewInitResult))
        {
        	    printf("GLEW ERROR: %s\n",glewGetErrorString(GlewInitResult));
                system("PAUSE");
                exit(EXIT_FAILURE);
        }
  
 
// For each function you need, grab the pointer
//PFNGLCREATEPROGRAMPROC glGenVertexArrays = NULL;
//glCreateProgram =  (PFNGLCREATEPROGRAMPROC)wglGetProcAddress("glCreateProgram");

Print(glGetString(GL_VERSION));
Print(glGetString(GL_RENDERER));
Print(wglGetCurrentContext());


#if 1
GLfloat Vertices[] = 
{
        0,0,0,
        0,3,0,
        8,3,0,
        8,0,0
};

GLushort Indices[] =
{
    0,1,2,
    2,3,0
};


//Buffer *vbo = new Buffer(Vertices,4 * 3, 3);
//Matrix4 Ortho = Matrix4::Orthographic(0.0f, 16.0f, 0.0f, 9.0f, -1.0f, 1.0);
#endif


#if 0
      Shader SHADER("basic.vert", "basic.frag");
      SHADER.Enable();
#endif
 
   glClearColor(0.0f, 0.0f, 0.0f, 1.0f);                    // Our own OpenGL initialization
   float scale = 0;
          while (GAME_LOOP())
       {

if(SCREEN->KEY_BOARD.KEY_STATES[GLFW_KEY_UP])scale+=.01;
if(SCREEN->KEY_BOARD.KEY_STATES[GLFW_KEY_DOWN])scale-=.01;


          Print(SCREEN->MOUSE.X);
          CLS();
          glMatrixMode(GL_PROJECTION);
         // glLoadIdentity();
          //glOrtho( 0.0, SCREENWIDTH, SCREENHEIGHT, 0.0, 1.0, -1.0 );
         _GL(gluPerspective(1,1,1,1));
          glLoadIdentity();
           Display();
            RenderScene5();
          SYNC();   
       }

  Main.DESTROY();
  glfwTerminate();
  return 0;

   return 0;
}






bool InitGL__()
{

    glMatrixMode( GL_PROJECTION );     //Initialize Projection Matrix
    glLoadIdentity();
    glOrtho( 0.0, SCREENWIDTH, SCREENHEIGHT, 0.0, 1.0, -1.0 );

    glMatrixMode( GL_MODELVIEW );     //Initialize Modelview Matrix
    glLoadIdentity();

    glClearColor( 0.f, 0.f, 0.f, 1.f );     //Initialize clear color

    GLenum error = glGetError();     //Check for error
    if( error != GL_NO_ERROR )
    {
        printf( "Error initializing OpenGL! %s\n", gluErrorString( error ) );
        return false;
    }
return true;
}


void Print_Shader_Log(GLuint){
}


void RenderScene5()
{
	angle = angle + .1;
    _GL(glMatrixMode( GL_PROJECTION));
    _GL(glLoadIdentity());
    _GL(glMatrixMode( GL_MODELVIEW));
    _GL(glLoadIdentity());



  // glTranslatef( SCREENWIDTH / 2.f, SCREENHEIGHT / 2.f, 1.f );
   _GL(glTranslatef( 0, 0,1.0f ));   // NEED TO FIGURE OUT WHY TRANLATE IS OFF.   // Translate back 6 units <- FUCK YOU TUTORIAL YOUR A LIAR!
    _GL(glMatrixMode( GL_MODELVIEW));
    _GL(glLoadIdentity());
    _GL(glRotatef(angle, 1.0f, 1.0f, 1.0f ));   

if(SCREEN->KEY_BOARD.KEY_STATES[GLFW_KEY_UP])scale+=.01;
if(SCREEN->KEY_BOARD.KEY_STATES[GLFW_KEY_DOWN])scale-=.01;
        _GL(glEnable( GL_DEPTH_TEST ));
  //  glTranslatef(0, 0, -translate );                     // Translate back 6 units
    glScalef(scale,scale,scale);
	glRotatef(angle, 1.0f, 1.0f, 1.0f );        // Rotate on all 3 axis
 
    _GL(glEnableClientState( GL_COLOR_ARRAY ));
    _GL(glEnableClientState( GL_VERTEX_ARRAY ));
 
    _GL(glColorPointer ( 3, GL_FLOAT, sizeof(VertexXYZColor), &(g_Vertices[0].m_Color)) );
    _GL(glVertexPointer( 3, GL_FLOAT, sizeof(VertexXYZColor), &(g_Vertices[0].m_Pos  ) ));
 
    _GL(glDrawElements( GL_QUADS, 24, GL_UNSIGNED_INT, &g_Indices[0] ));
 
    _GL(glDisableClientState( GL_COLOR_ARRAY ));
    _GL(glDisableClientState( GL_VERTEX_ARRAY ));
}



//RESIZE CALLBACK
   // Compute aspect ratio of the new window
  // if (h == 0) h = 1;                // To prevent divide by 0
  // GLfloat aspect = (GLfloat)w / (GLfloat)h;
 
   // Set the viewport to cover the new window
  // glViewport(0, 0, w, h);
 
   // Set the aspect ratio of the clipping area to match the viewport
/*   glMatrixMode(GL_PROJECTION);  // To operate on the Projection matrix
   glLoadIdentity();             // Reset the projection matrix
   if (w >= h) {
     // aspect >= 1, set the height from -1 to 1, with larger width
      gluOrtho2D(-1.0 * aspect, 1.0 * aspect, -1.0, 1.0);
   } else {
      // aspect < 1, set the width to -1 to 1, with larger height
     gluOrtho2D(-1.0, 1.0, -1.0 / aspect, 1.0 / aspect);
   }*/










    //?/INIT_( argc,  args );

#if 0
    Image SPRITE;
    SPRITE.X = 1;
    SPRITE.Y = 1;
    SPRITE.H = 10;
    SPRITE.W = 10;

    GLfloat VERTICES[] = {
        0,0,0,
        8,0,0,
        0,3,0,
        0,3,0,
        8,3,0,
        8,0,0,
    };

    GLushort INDEX[] = {
         1,2,3,4
    };
#endif

   GLfloat VERTICES[] = {
        0,0,0,
        0,3,0,
        8,3,0,
        8,0,0,
    };
   GLushort INDICES[] = {
        0,1,2,
        2,3,0,
    };

Buffer *vbo = new Buffer(VERTICES,4 * 3, 3);
IndexBuffer IBO(INDICES,6);

Matrix4 Ortho = Matrix4::Orthographic(0.0f, 16.0f, 0.0f, 9.0f, -1.0f, 1.0);

       float ANG;



	   ///
///Shader SHADER("basic.vert", "basic.frag");
///SHADER.Enable();
///SHADER.SetUniformMat4("pr_matrix",Ortho);
///SHADER.SetUniformMat4("ml_matrix",Matrix4::Translation(Vec3(3,4,0)));
///SHADER.SetUniform2f("light_pos",Vec2(4.0f,1.5f));

     //    SPRITE.X, SPRITE.Y,0,
    //     SPRITE.X, SPRITE.H,0,
    //     SPRITE.W, SPRITE.Y,0,
     //    SPRITE.W, SPRITE.H,0,








	 
// (left, bottom, -near) is the coordinates of the screen lower left corner and (right, top, -near) the upper right one.
   // glOrtho(  0.0,     //   left
   //         640.0,   //   right
   //         480.0,   //   bottom
   //           0.0,   //   top
   //           1.0, 
   //          -1.0 );


        


===================================================================================================================================================
                                                                     SHADER 
___________________________________________________________________________________________________________________________________________________
===================================================================================================================================================

   // minimal fragment shader
// www.lighthouse3d.com
#version 200 core

layout (location =0) out vec4 color;

uniform vec4 color;
uniform vec2 light_pos;

int DATA
{
   vec4 position
   vec4 color;
} fs_in;

void main()
{
  //float intensity = 1.0 / length(fs_in.position.xy - light_pos);
  color = fs_in.color;
}



===================================================================================================================================================
                                                                      3/27/2018 
___________________________________________________________________________________________________________________________________________________
===================================================================================================================================================




PFNGLCREATEPROGRAMPROC glGenVertexArrays = NULL;
glCreateProgram =  (PFNGLCREATEPROGRAMPROC)wglGetProcAddress("glCreateProgram");


//DONT FORGET TO HANDLE GENERATING THE FUCKING FRAME BUFFER CORRECTLY
//_GL(glGenFramebuffers(1,&SCREEN->FRAME_BUFFER.NAME));
//glfwGetFramebufferSize(SCREEN->glCONTEXT,&SCREEN->FRAME_BUFFER.WIDTH, &SCREEN->FRAME_BUFFER.HEIGHT); 
// Retrieves the size of the frame buffer and places it into the class

 if(GetGLFunction("GL_ARB_draw_buffers") == NULL)Print("No VAO");

 
 // GLushort BOXIBO[] = {
 //     6,5,7,  7,8,6,  6,8,4,  8,2,4,
 //     8,7,1,  1,8,2,  6,5,3,  3,4,6,
 //     1,2,4,  4,3,1,  5,3,1,  7,1,3,
 // };


 




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                         NOTES/TODO/DEPRECIATED CODE/ETC.......                                                                                                  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//void glVertexPointer(GLint 	size,GLenum	type,	GLsizei	stride,	const GLvoid *VERTEX_ptr);
//GLubyte *a =  gluErrorString()
//	GLenum WINAPI glGetError


===================================================================================================================================================
                                              3/28/2018 
___________________________________________________________________________________________________________________________________________________
===================================================================================================================================================

 //  glFrustum(
 //      0.0, 
 //      0.0, 
 //    480.0, 
 //    640.0, 
 //      -.50, 
 //      1000.0);

 BASICvert.cpp
 gl_Position = pr_matrix * vw_matrix * ml_matrix * position;
vs_out.position = ml_matrix * position;
vs_out.color = color;



// MAIN.CPP, BOX DRAWING ATTEMPT

  GLfloat VERTICES[] = {0,0,0,0,3,0,8,3,0, 8,0,0 };
  GLushort INDICES[] = {0,1,2, 2,3,0};

  GLfloat BOX[] = {
        -.5, -.5, -.5, 
        -.5,  .5, -.5,
         .5,  .5, -.5, 
         .5, -.5, -.5,
   };

   GLushort BOXIBO[]={
       0, 1, 2,
       2, 3, 0
   };

GLfloat Square[] = {
       -1.0,-1.0,-.5
       -.5,-.5,-.5
};

Buffer  VBO(BOX, 3 * 8, 3);    // Buffer(GLfloat *data,GLsizei count,GLint componentcount);
IndexBuffer IBO(BOXIBO,12);


MAIN.cpp

void INIT_( int argc, char* args[] )
{
           //Initialize Projection Matrix
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity();
    glOrtho( 0.0, SCREEN->WIDTH, SCREEN->HEIGHT, 0.0, 1.0, -1.0 );

    //Initialize Modelview Matrix
    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity();

}





===================================================================================================================================================
                                              3/31/2018  
___________________________________________________________________________________________________________________________________________________
===================================================================================================================================================

------ RENDERER H -----------------------------------------------------
struct float3
{
    float3( float _x = 0.0f, float _y = 0.0f, float _z = 0.0f ) 
        : x(_x), y(_y), z(_z) {}
    float x;
    float y;
    float z;
};
 
// Vertex definition
struct VertexXYZColor
{
    float3 m_Pos;
    float3 m_Color;
};



SHADER.CPP

// Define the 8 vertices of a unit cube
VertexXYZColor g_Vertices[8] = {
    { float3(  1,  1,  1 ), float3( GL_Color(255),  GL_Color(0),  GL_Color(0) ) }, // 0
    { float3( -1,  1,  1 ), float3( GL_Color(0),  GL_Color(0),  GL_Color(255)) }, // 1
    { float3( -1, -1,  1 ), float3(GL_Color(0),  GL_Color(255),  GL_Color(0)) }, // 2

    { float3(  1, -1,  1 ), float3(GL_Color(255),  GL_Color(0),  GL_Color(255)) }, // 3
    { float3(  1, -1, -1 ), float3(GL_Color(255),  GL_Color(255),  GL_Color(0) ) }, // 4
    { float3( -1, -1, -1 ), float3(GL_Color(0),  GL_Color(255),  GL_Color(255)) }, // 5

    { float3( -1,  1, -1 ), float3( GL_Color(255),  GL_Color(255),  GL_Color(50) ) }, // 6
    { float3(  1,  1, -1 ), float3( GL_Color(0),  GL_Color(50),  GL_Color(255) ) }, // 7
};







// NOTES FROM MAIN CPP
//glFrustum for PROJECTION, 
//and/or glTranslated or glRotated for MODELVIEW. –

//==========================================================================================================================
//__________________________________________________________________________________________________________________________
//==========================================================================================================================



// Setup Window
// Setup Viewport to 0,0 window Height/Window Width
// Set GluPerspective to change the Clipping plane
// 
//GL_EXT_framebuffer_object

//  LIGHTING
//  GLfloat light0_position[] = { 0, 0, 1, 0 };
//  GLfloat light0_brightness = { 1, 1, 1, 1 };
//  glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
//  glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_brightness);
//  glLightfv(GL_LIGHT0, GL_SPECULAR, light0_brightness);
//
//



    // glMatrixMode(GL_MODELVIEW);
    // glLoadIdentity();
    // glRotatef(angle, 1,0,0);
    //
    // glColor3f (GL_Color(155), 1.0, 1.0);
    // glCallList(theTorus);
    //
    // glRotatef(90, 1,0,0);
    // glCallList(theTorus);
    //
    //  a = 1.0 / 640.0 * (SCREENWIDTH);
    //
    //
    // glMatrixMode(GL_PROJECTION);
    // glLoadIdentity();
    // glTranslatef(XPos,YPos,Zpos);
    //
	
//CameraX += SCREEN->MOUSE.MouseMoveX;//(SCREEN->MOUSE.X) ;
//CameraY += SCREEN->MOUSE.MouseMoveY;//(-SCREEN->MOUSE.Y);
//CameraX = fmod(CameraX,360);
//CameraY = fmod(CameraY,360);
         //glRotatef(angle, 0.0, 1.0, 0.0);

//C//am.handleMouseMove(SCREEN->MOUSE.X, SCREEN->MOUSE.Y);




//==========================================================================================================================
//_______________________________ 4 - 1 ___________________________________________________________________________
//==========================================================================================================================



Main CPP
    glLoadIdentity();

 // Get the MouseMovement 
    MOVEX = SCREEN->MOUSE.X - OLDMX;
    MOVEY = SCREEN->MOUSE.Y - OLDMY;
    OLDMX = SCREEN->MOUSE.X;
    OLDMY = SCREEN->MOUSE.Y;
// APPLY MouseMovement to the Camera Rotation
    CameraX += MOVEX;
    CameraY += MOVEY;
// Translate the World <- This is wrong, Its translating the Camera 
 //   glTranslatef(0, 0,ZPos); 
    glTranslatef(XPos, YPos, ZPos);

// Rotate the world
    glRotatef(CameraY / 2, -10, 0.0, 0.0);
    glRotatef(CameraX / 2, 0, -10, 0.0);
//
//glTranslatef(0.0, 0.0, -10.0); // This is translating the world I think... orr something...
    glTranslatef(XPos, YPos, ZPos);



//Print(SCREEN->MOUSE.MouseMoveX );
//Print(SCREEN->MOUSE.MouseMoveY );

     //  glCallList(theTorus);
     //  glRotatef(90,0,.10,.0);

//for(int ycount = 0 ; ycount < 10; ycount++){
  //  _GL(glPushMatrix());
     //
     //glTranslatef(0.0,
     //        ycount * 1.0, 
     //         0.0);
     //
//for(int xcount = 0 ; xcount < 10; xcount++){
 
   for(Torus &List: ObjectList){
       List.Render();
       glCallList(List.List);
   }
   //    glTranslatef(xcount * 1.0,
   ///                 ycount, 
   ///              0.0);
   /// glRotatef(90,0.0 ,0.0,1.0);
   /// glTranslatef(0.0,
   ///               0.0, 
   ///              -5.0 );
   /// glPopMatrix();
//}


//_GL(glPopMatrix());
//}
       // glMatrixMode(GL_MODELVIEW);
       // glLoadIdentity();
       // glCallList(theTorus);
       // glTranslatef(.0,10.0,.0);
//Print("XPos: ";Print(XPos));
///Print("YPos: ";Print(YPos)); 


    SYNC();

    }
}



//===========================  SPHERE  ================================
//
// float rings = 8.0f;
// float sectors = 16.0f;
// float radius = 1.0;
//     float const R = 1.0 /(float)(rings-1);
// float const S = 1.0 /(float)(sectors-1);
// int r, s;
// float X,Y,Z;
// 
// for(r = 0; r < rings; r++) for(s = 0; s < sectors; s++) {
//     float const y = sin( -M_PI_2 + M_PI * r * R );
//     float const x = cos(2*M_PI * s * S) * sin( M_PI * r * R );
//     float const z = sin(2*M_PI * s * S) * sin( M_PI * r * R );
//         X = x * radius;
//         Y = y * radius;
//         Z = z * radius;
//
//     glBegin(GL_TRIANGLES);
//     glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
//
//     glVertex3f(X,Y,Z);
//  //   glNormal3f(X,Y,Z);
//     glEnd();
//}
 //   for(float x = 1;x < 640;x+=.1){
 //       for(float y =1;y < 480;y+=.1){
 //         glBegin(GL_POINTS);
 //         _GL(glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(155.0)));
 //         _GL(glVertex3f(x * .01 , y * .01, 1.));
 //        // _GL(glNormal3f(x, y,-1.));
 //         glEnd();
 //       }
 //   }


 MAIN.CPP

 
static void torus(int numc, int numt)
{
    int i, j, k;
    double s, t, x, y, z, twopi;
    
    twopi = 2 * (double)M_PI;

    for (i = 0; i < numc; i++) {
         _GL(glBegin(GL_QUAD_STRIP));
        for (j = 0; j <= numt; j++) {
            for (k = 1; k >= 0; k--) {
                s = (i + k) % numc + 0.5;
                t = j % numt;
                
                x = (1+.1*cos(s*twopi/numc))*cos(t*twopi/numt);
                y = (1+.1*cos(s*twopi/numc))*sin(t*twopi/numt);
                z = .1 * sin(s * twopi / numc);
                
               _GL(glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(155.0)));
               _GL(glVertex3f(x, y, z));
               _GL(glNormal3f(x, y, z));
            }
        }
        glEnd();
    }
}

static void init(void)
{
   theTorus = glGenLists (1);
   glNewList(theTorus, GL_COMPILE);
   torus(20, 45);
   glEndList();

   glShadeModel(GL_FLAT);
   glClearColor(0.0, 0.0, 0.0, 0.0);
}


void *GetGLFunction(const char *name){
    void *p = (void *)wglGetProcAddress("glGenVertexArrays");
    if(p == 0 || 
        (p == (void*)0x1) || (p == (void*)0x2) || (p==(void*)0x3) ||
        (p == (void*)-1) )
    {
        HMODULE module = LoadLibraryA("Opengl32.dll");
            p=(void*)GetProcAddress(module,name);
    }
    return p;
}







static void torus(int numc, int numt);

void INIT_( int argc, char* args[] );

GLuint theTorus;


3DPrimative.CPP


void Object::Rotate(float angle){
       glMatrixMode(GL_MODELVIEW);         // To operate on Model-View matrix
       glLoadIdentity();                   // Reset the model-view matrix
       glPushMatrix();                     // Save model-view matrix setting
       glTranslatef(-0.5f, 0.4f, 0.0f);    // WARNING:: Set this to the objects current translation 
       glRotatef(angle, 0.0f, 0.0f, 1.0f); // rotate by angle in degrees
}



Cube::Cube(float size, GLuint Color){
float  VetexData[]={
    -1.0f,-1.0f,-1.0f,  
    -1.0f,-1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f, // triangle 1 : end
    1.0f, 1.0f,-1.0f, // triangle 2 : begin
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f, // triangle 2 : end
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f};

 glDrawArrays(GL_TRIANGLES, 0, 12*3); // 12*3 indices starting at 0 -> 12 triangles -> 6 squares


}

GLuint Primitive::CUBE2 (Vec3 pos,float size){
        Vec3_COLOR TempMesh[8] = {
            { Vec3(  1,  1,  1 ), Vec3( 1, 1, 1 ) }, // 0
            { Vec3( -1,  1,  1 ), Vec3( 0, 0, 0 ) }, // 1
            { Vec3( -1, -1,  1 ), Vec3( 0, 0, 1 ) }, // 2
            { Vec3(  1, -1,  1 ), Vec3( 1, 0, 1 ) }, // 3
            { Vec3(  1, -1, -1 ), Vec3( 1, 0, 0 ) }, // 4
            { Vec3( -1, -1, -1 ), Vec3( 0, 0, 0 ) }, // 5
            { Vec3( -1,  1, -1 ), Vec3( 0, 1, 0 ) }, // 6
            { Vec3(  1,  1, -1 ), Vec3( 1, 1, 0 ) }, // 7
        };
        
        GLuint g_Indices[24] = {
            0, 1, 2, 3,                 // Front face
            7, 4, 5, 6,                 // Back face
            6, 5, 2, 1,                 // Left face
            7, 0, 3, 4,                 // Right face
            7, 6, 1, 0,                 // Top face
            3, 2, 5, 4,                 // Bottom face
        };
        GLuint buff;
  //      glGenBuffers(1,&buff);   FIX ALL OF THIS I BELIEVE MY GEN INDEX BUFFER IS MISTAKEN
  //  /  _GL(glBindBuffer(GL_ARRAY_BUFFER,buff)); 
  //    _GL(glBufferData(GL_ELEMENT_INDEX_BUFFER,count * sizeof(GLushort),data,GL_STATIC_DRAW));
//glGenTextures(1, &texture1);// Create The Texture name
//glBindTexture(GL_TEXTURE_2D, texture1);
        return NULL;
}
                                                                                                                                                                                                                                                                            
GLuint Make_Triangle(float size)
{
    size = -1;
    float z = -4;
        GLuint displayList = glGenLists(1);
        glNewList( displayList, GL_COMPILE );
                glBegin(GL_TRIANGLES);
                        glVertex3f(-size, -size/2, -z);
                        glVertex3f( size, -size/2, -z);
                        glVertex3f( 0.0f,  size/2, -z);
                glEnd();
return displayList;
}

GLuint Primitive::CUBE (Vec3 pos,float size){
    // The distance from the center to the outside of the cube
    // is half the size.
    size = size / 2.0f;
 
    GLuint displayList = glGenLists(1);
    if(!displayList) Print("Failed to make Object:CUBE");

    glNewList( displayList, GL_COMPILE );
    {
        glBegin( GL_QUADS );
        // Top face
        glColor3f(   0.0f, 1.0f,  0.0f );  // Green
        glVertex3d(  size, size, -size );  // Top-right of top face
        glVertex3f( -size, size, -size );  // Top-left of top face
        glVertex3f( -size, size,  size );  // Bottom-left of top face
        glVertex3f(  size, size,  size );  // Bottom-right of top face
 
        // Bottom face
        glColor3f(   1.0f,  0.5f,  0.0f ); // Orange
        glVertex3f(  size, -size, -size ); // Top-right of bottom face
        glVertex3f( -size, -size, -size ); // Top-left of bottom face
        glVertex3f( -size, -size,  size ); // Bottom-left of bottom face
        glVertex3f(  size, -size,  size ); // Bottom-right of bottom face
 
        // Front face
        glColor3f(   1.0f,  0.0f, 0.0f );  // Red
        glVertex3f(  size,  size, size );  // Top-Right of front face
        glVertex3f( -size,  size, size );  // Top-left of front face
        glVertex3f( -size, -size, size );  // Bottom-left of front face
        glVertex3f(  size, -size, size );  // Bottom-right of front face
 
        // Back face
        glColor3f(   1.0f,  1.0f,  0.0f ); // Yellow
        glVertex3f(  size, -size, -size ); // Bottom-Left of back face
        glVertex3f( -size, -size, -size ); // Bottom-Right of back face
        glVertex3f( -size,  size, -size ); // Top-Right of back face
        glVertex3f(  size,  size, -size ); // Top-Left of back face
 
        // Left face
        glColor3f(   0.0f,  0.0f,  1.0f);  // Blue
        glVertex3f( -size,  size,  size);  // Top-Right of left face
        glVertex3f( -size,  size, -size);  // Top-Left of left face
        glVertex3f( -size, -size, -size);  // Bottom-Left of left face
        glVertex3f( -size, -size,  size);  // Bottom-Right of left face
 
        // Right face
        glColor3f(   1.0f,  0.0f,  1.0f);  // Magenta
        glVertex3f(  size,  size,  size);  // Top-Right of left face
        glVertex3f(  size,  size, -size);  // Top-Left of left face
        glVertex3f(  size, -size, -size);  // Bottom-Left of left face
        glVertex3f(  size, -size,  size);  // Bottom-Right of left face
        glEnd();        
    }
    glEndList();
 
    return displayList;
}




GLSL Version	OpenGL   Version	     Date Shader Preprocessor

1.10.59	         2.0	April 2004	          #version 110
1.20.8	         2.1	September 2006	      #version 120
1.30.10	         3.0	August 2008	          #version 130
1.40.08          3.1	March 2009	          #version 140
1.50.11          3.2	August 2009	          #version 150
3.30.6           3.3	February 2010	      #version 330
4.00.9           4.0	March 2010 	          #version 400
4.10.6           4.1	July 2010	          #version 410
4.20.11          4.2	August 2011	          #version 420
4.30.            4.3	August 2012	          #version 430
4.40 	         4.4	July 2013	          #version 440
4.50             4.5	August 2014	          #version 450
4.60 	         4.6	July 2017	          #version 460







































const double Camera::TO_RADS = 3.141592654 / 180.0; // The value of 1 degree in radians
 
Camera::Camera(float theWindowWidth, float theWindowHeight)
{
	initCamera();
 
	windowWidth  = theWindowWidth;
	windowHeight = theWindowHeight;
 
// Calculate the middle of the window
	windowMidX = windowWidth  / 2.0f;
	windowMidY = windowHeight / 2.0f;
}
 

 
void Camera::initCamera()
{
	// Set position, rotation and speed values to zero
	position.x = 0;
	position.y = 0;
	position.z = 0;

	rotation.x = 0;
	rotation.y = 0;
	rotation.z = 0;


	speed.x = 0;
    speed.y = 0;
    speed.z = 0;

	// How fast we move (higher values mean we move and strafe faster)
	movementSpeedFactor = 10.0;
 
	pitchSensitivity = 0.2; // How sensitive mouse movements affect looking up and down
	yawSensitivity   = 0.2; // How sensitive mouse movements affect looking left and right
 
// To begin with, we aren't holding down any keys
	holdingForward     = false;
	holdingBackward    = false;
	holdingLeftStrafe  = false;
	holdingRightStrafe = false;
}
 
// Function to convert degrees to radians
const double Camera::toRads(const double &theAngleInDegrees) const
{
	return theAngleInDegrees * TO_RADS;
}
 
// Function to deal with mouse position changes
void Camera::handleMouseMove(int mouseX, int mouseY)
{
	// Calculate our horizontal and vertical mouse movement from middle of the window
	double horizMovement = mouseX ; //- windowMidX+1) * yawSensitivity;
	double vertMovement  = mouseY; //- windowMidY) * pitchSensitivity;
 
	//std::cout << "Mid window values: " << windowMidX << "\t" << windowMidY << std::endl;
	//std::cout << "Mouse values     : " << mouseX << "\t" << mouseY << std::endl;
	//std::cout << horizMovement << "\t" << vertMovement << std::endl << std::endl;
   //
	// Apply the mouse movement to our rotation vector. The vertical (look up and down)
	// movement is applied on the X axis, and the horizontal (look left and right)
	// movement is applied on the Y Axis
	rotation.x +=(vertMovement);
	rotation.y +=(horizMovement);
 
//// Limit loking up to vertically up
//if (rotation.x < -90)
//{
//	rotation.x = (-90);
//}
//
//// Limit looking down to vertically down
//if (rotation.x > 90)
//{
//	rotation.x = (90);
//}
//
	// If you prefer to keep the angles in the range -180 to +180 use this code
	// and comment out the 0 to 360 code below.
	//
	// Looking left and right. Keep the angles in the range -180.0f (anticlockwise turn looking behind) to 180.0f (clockwise turn looking behind)
	/*if (yRot < -180.0f)
	{
	    yRot += 360.0f;
	}
 
	if (yRot > 180.0f)
	{
	    yRot -= 360.0f;
	}*/
 
	// Looking left and right - keep angles in the range 0.0 to 360.0
	// 0 degrees is looking directly down the negative Z axis "North", 90 degrees is "East", 180 degrees is "South", 270 degrees is "West"
	// We can also do this so that our 360 degrees goes -180 through +180 and it works the same, but it's probably best to keep our
	// range to 0 through 360 instead of -180 through +180.
//if (rotation.y < 0)
//{
//	rotation.y+=(360);
//}
//if (rotation.y > 360)
//{
//	rotation.y+=(-360);
//}
 
	// Reset the mouse position to the centre of the window each frame
	//./glfwSetCursorePos(SCREEN->glCONTEXT, windowMidX, windowMidY);
    //glfwSetCursorPos(SCREEN->glCONTEXT, windowMidX, windowMidY);
}
 
// Function to calculate which direction we need to move the camera and by what amount

void Camera::MoveForward(float distance){
    	Vec3  movement;
	float sinXRot = sin( toRads( rotation.x ) );
	float cosXRot = cos( toRads( rotation.x ) );
 
	float sinYRot = sin( toRads( rotation.y ) );
	float cosYRot = cos( toRads( rotation.y ) );
 
	float pitchLimitFactor = cosXRot; // This cancels out moving on the Z axis when we're looking up or down
 
		movement.x+=(sinYRot * pitchLimitFactor);
		movement.y+=(-sinXRot);
		movement.z+=(-cosYRot * pitchLimitFactor);

	movement.Normalize();

    	position += movement;
}

void Camera::MoveBackward(float distance){
    	Vec3  movement;
	float sinXRot = sin( toRads( rotation.x ) );
	float cosXRot = cos( toRads( rotation.x ) );
 
	float sinYRot = sin( toRads( rotation.y ) );
	float cosYRot = cos( toRads( rotation.y ) );
 
	float pitchLimitFactor = cosXRot; // This cancels out moving on the Z axis when we're looking up or down
 
		movement.x+=(sinYRot * pitchLimitFactor);
		movement.y+=(-sinXRot);
		movement.z+=(-cosYRot * pitchLimitFactor);
	movement.Normalize();
    	position += movement;
}

void Camera::MoveLeft(float distance){
    	Vec3  movement;
	float sinXRot = sin( toRads( rotation.x ) );
	float cosXRot = cos( toRads( rotation.x ) );
 
	float sinYRot = sin( toRads( rotation.y ) );
	float cosYRot = cos( toRads( rotation.y ) );
 
	float pitchLimitFactor = cosXRot; // This cancels out moving on the Z axis when we're looking up or down
 
		movement.x += (-cosYRot);
		movement.z +=(-sinYRot);
	movement.Normalize();
    	position += movement;
}

void Camera::MoveRight(float distance){
	Vec3  movement;
	float sinXRot = sin( toRads( rotation.x ) );
	float cosXRot = cos( toRads( rotation.x ) );
 
	float sinYRot = sin( toRads( rotation.y ) );
	float cosYRot = cos( toRads( rotation.y ) );
 
	float pitchLimitFactor = cosXRot; // This cancels out moving on the Z axis when we're looking up or down
 
	movement.x +=(cosYRot);
	movement.z +=(sinYRot);
    movement.Normalize();
    position += movement;




//===================================================================================================================================================================
//==========================================                        =====================================================================================================
//==========================================     CAMERA.H           ==================================================================================================
//===================================================================================================================================================================

	class Camera
{
    protected:

     
        double movementSpeedFactor; // Controls how fast the camera moves
        double pitchSensitivity;    // Controls how sensitive mouse movements affect looking up and down
        double yawSensitivity;      // Controls how sensitive mouse movements affect looking left and right
     
        // Window size in pixels and where the midpoint of it falls
        int windowWidth;
        int windowHeight;
        int windowMidX;
        int windowMidY;
     
        // Method to set some reasonable default values. For internal use by the class only.
        void initCamera();
     
    public:


        Matrix4 ViewMatrix;

        Vec3 rotation;


        Vec3 position;
        Vec3 View;
        Vec3 Up;
            
        // Camera movement speed. When we call the move() function on a camera, it moves using these speeds
        Vec3 speed;

        static const double TO_RADS; // The value of 1 degree in radians

        float Timer;

        // Holding any keys down?
        bool holdingForward;
        bool holdingBackward;
        bool holdingLeftStrafe;
        bool holdingRightStrafe;
        bool ViewChanged;
        // Constructor
        Camera(float windowWidth, float windowHeight);
     
        // Destructor
        ~Camera(){}
     
        // Mouse movement handler to look around
        void handleMouseMove(int mouseX, int mouseY);
     
        // Method to convert an angle in degress to radians
        const double toRads(const double &angleInDegrees) const;
     
        // Method to move the camera based on the current direction
        void MoveForward(float distnace);
        void MoveBackward(float distance);
        void MoveLeft(float distance);
        void MoveRight(float distance);
        void PositionCamera(float,float,float, float,float,float, float,float,float);
        // --------------------------------- Inline methods ----------------------------------------------
     
        // Setters to allow for change of vertical (pitch) and horizontal (yaw) mouse movement sensitivity
        float getPitchSensitivity()            { return pitchSensitivity;  }
        void  setPitchSensitivity(float value) { pitchSensitivity = value; }
        float getYawSensitivity()              { return yawSensitivity;    }
        void  setYawSensitivity(float value)   { yawSensitivity   = value; }
     
        // Position getters
        Vec3  getPosition() const { return position;        }
        double getXPos()           const { return position.x; }
        double getYPos()           const { return position.y; }
        double getZPos()           const { return position.z; }
     
        // Rotation getters
        Vec3  getRotation() const { return rotation;        }
        double getXRot()           const { return rotation.x; }
        double getYRot()           const { return rotation.y; }
        double getZRot()           const { return rotation.z; }


        void Rotate(float x, float y);
};
 //===================================================================================================================================================================
//==========================================                        =====================================================================================================
//==========================================     CAMERA.CPP           ==================================================================================================
//===================================================================================================================================================================
Camera::Camera(float theWindowWidth, float theWindowHeight)
{
	initCamera();
 
	windowWidth  = theWindowWidth;
	windowHeight = theWindowHeight;

	windowMidX = windowWidth  / 2.0f;
	windowMidY = windowHeight / 2.0f;
    

}
 

 
void Camera::initCamera()
{
	// Set position, rotation and speed values to zero
	position.x = 0;
	position.y = 0;
	position.z = 0;

	rotation.x = 0;
	rotation.y = 0;
	rotation.z = 0;

    Up.x = 0.0f;
    Up.y = 1.0f;
    Up.z = 0.0f;
    
    speed.x = 0;
    speed.y = 0;
    speed.z = 0;

	// How fast we move (higher values mean we move and strafe faster)
	movementSpeedFactor = 10.0;
 
	pitchSensitivity = 0.2; // How sensitive mouse movements affect looking up and down
	yawSensitivity   = 0.2; // How sensitive mouse movements affect looking left and right
 
// To begin with, we aren't holding down any keys
	holdingForward     = false;
	holdingBackward    = false;
	holdingLeftStrafe  = false;
	holdingRightStrafe = false;

    ViewMatrix = LookAt(position, rotation, Up);
}
 
// Function to convert degrees to radians
const double Camera::toRads(const double &theAngleInDegrees) const
{
    return theAngleInDegrees * TO_RADS;
}
 
// Function to deal with mouse position changes
void Camera::handleMouseMove(int mouseX, int mouseY){
}
 

void Camera::MoveForward(float distance){
    Vec3 movement(0,0,0);

    movement.x+=( sin(RADIANS(rotation.y)));// * pitchLimitFactor);
	movement.y+=( sin(RADIANS(rotation.x)));
	movement.z+=(-cos(RADIANS(rotation.y)));// * pitchLimitFactor);

    position.x -= movement.x;
    position.y -= movement.y;
    position.z -= movement.z;
}

void Camera::MoveBackward(float distance){
    Vec3 movement(0,0,0);

    movement.x+=( sin(RADIANS(rotation.y)));// * pitchLimitFactor);
	movement.y+=(-sin(RADIANS(rotation.x)));
	movement.z+=(-cos(RADIANS(rotation.y)));// * pitchLimitFactor);

    position.x += movement.x;
    position.y += movement.y;
    position.z += movement.z;
}

void Camera::MoveLeft(float distance){

}

void Camera::MoveRight(float distance){
}




	// Vector to break up our movement into components along the X, Y and Z axis
// Get the sine and cosine of our X and Y axis rotation
//// Calculate our value to keep the movement the same speed regardless of the framerate...
//double framerateIndependentFactor = movementSpeedFactor * deltaTime;
//
//// .. and then apply it to our movement vector.
//movement.x *= framerateIndependentFactor;
//movement.y *= framerateIndependentFactor;
//movement.z *= framerateIndependentFactor;

// Finally, apply the movement to our position


void Camera::Rotate(float x, float y)
{
    const float multiplier = M_PI / 6.f;

    if (y)
    {
        y = -y;
        float theta = multiplier * y;
        auto prev_dir = Vec3::Normalize(rotation), 
             prev_up = Vec3::Normalize(Up);

        rotation = Vec3::Normalize( (prev_dir * std::cos(theta)) + (prev_up * std::sin(theta)));
    }
    if (x)
    {
        float theta = multiplier * x;
        auto prev_dir = Vec3::Normalize(rotation);
        auto cross  = Vec3::Normalize(Vec3::CrossProduct(rotation, Up));
        rotation = Vec3::Normalize( (prev_dir * std::cos(theta)  + (cross * std::sin(theta) )));
    }
    Timer = 0.3f;
    ViewChanged = true;
}






// TURN ON WHEN ADDED TO THE REST OF THE VERTEX CLASS

#if 0
 

// ===================================================================================================================================
// _____________________________________________ FPS Class Manager ___________________________________________________________________
// ===================================================================================================================================
//                    https://r3dux.org/2012/12/fpsmanager-a-c-helper-class-for-framerate-independent-movement/

#include <string>
#include <sstream>
 
#ifndef __glfw_h_
    #include <GL/glfw.h> // We need GLFW for this, so let's check for it- although it'd be a doddle to convert to non-GLFW using code.
#endif
 
/** The FpsManager class is designed to work with GLFW and enforces a specified framerate on an application.
  * It can also display the current framerate at user-specified intervals, and in addition returns the time
  * duration since the last frame, which can be used to implement framerate independent movement.
  *
  * Author: r3dux
  * Revision: 0.3
  * Date: 1st September 2013
  *
  * ---- Creation examples (it's most useful to create your fpsManager object globally in your Main.cpp file): ----
  *
  *     FpsManager fpsManager(60.0);                    // Lock to 60fps, no reporting of framerate
  *
  *     FpsManager fpsManager(85.0, 3.0);               // Lock to 85fps, output FPS to console once every three seconds
  *
  *     FpsManager fpsManager(30.0, 0.5, "My App");     // Lock to 30fps, output FPS to console & window title every half second
  *
  *
  * ---- Using the fpsManager in your main loop: ----
  *
  * bool running     = true;
  * double deltaTime = 0.0;
  *
  * while (running)
  * {
  *     // Calculate our camera movement
  *     cam->move(deltaTime);
  *
  *     // Draw our scene
  *     drawScene();
  *
  *     // Exit if ESC was pressed or window was closed
  *     running = !glfwGetKey(GLFW_KEY_ESC) && glfwGetWindowParam(GLFW_OPENED);
  *
  *     // Call our fpsManager to limit the FPS and get the frame duration to pass to the cam->move method
  *     deltaTime = fpsManager.enforceFPS();
  * }
  *
  * That's it! =D
  */
 
class FpsManager
{
 
    private:
        double frameStartTime;         // Frame start time
        double frameEndTime;           // Frame end time
        double frameDuration;          // How many milliseconds between the last frame and this frame
 
        double targetFps;              // The desired FPS to run at (i.e. maxFPS)
        double currentFps;             // The current FPS value
        int    frameCount;             // How many frames have been drawn s
 
        double targetFrameDuration;    // How many milliseconds each frame should take to hit a target FPS value (i.e. 60fps = 1.0 / 60 = 0.016ms)
        double sleepDuration;          // How long to sleep if we're exceeding the target frame rate duration
 
        double lastReportTime;         // The timestamp of when we last reported
        double reportInterval;         // How often to update the FPS value
 
        std::string windowTitle;       // Window title to update view GLFW
 
        bool verbose;                  // Whether or not to output FPS details to the console or update the window
 
        // Limit the minimum and maximum target FPS value to relatively sane values
        static const double MIN_TARGET_FPS = 20.0;
        static const double MAX_TARGET_FPS = 60.0; // If you set this above the refresh of your monitor and enable VSync it'll break! Be aware!
 
        // Private method to set relatively sane defaults. Called by constructors before overwriting with more specific values as required.
        void init(double theTargetFps, bool theVerboseSetting)
        {
            setTargetFps(theTargetFps);
 
            frameCount     = 0;
            currentFps     = 0.0;
            sleepDuration  = 0.0;
            frameStartTime = glfwGetTime();
            frameEndTime   = frameStartTime + 1;
            frameDuration  = 1;
            lastReportTime = frameStartTime;
            reportInterval = 1.0f;
            windowTitle    = "NONE";
            verbose        = theVerboseSetting;
        }
 
    public:
 
        // Single parameter constructor - just set a desired framerate and let it go.
        // Note: No FPS reporting by default, although you can turn it on or off later with the setVerbose(true/false) method
        FpsManager(int theTargetFps)
        {
            init(theTargetFps, false);
        }
 
        // Two parameter constructor which sets a desired framerate and a reporting interval in seconds
        FpsManager(int theTargetFps, double theReportInterval)
        {
            init(theTargetFps, true);
 
            setReportInterval(theReportInterval);
        }
 
        // Three parameter constructor which sets a desired framerate, how often to report, and the window title to append the FPS to
        FpsManager(int theTargetFps, float theReportInterval, std::string theWindowTitle)
        {
            init(theTargetFps, true); // If you specify a window title it's safe to say you want the FPS to update there ;)
 
            setReportInterval(theReportInterval);
 
            windowTitle = theWindowTitle;
        }
 
        // Getter and setter for the verbose property
        bool getVerbose()
        {
            return verbose;
        }
        void setVerbose(bool theVerboseValue)
        {
            verbose = theVerboseValue;
        }
 
        // Getter and setter for the targetFps property
        int getTargetFps()
        {
            return targetFps;
        }
 
        void setTargetFps(int theFpsLimit)
        {
            // Make at least some attempt to sanitise the target FPS...
            if (theFpsLimit < MIN_TARGET_FPS)
            {
                theFpsLimit = MIN_TARGET_FPS;
                std::cout << "Limiting FPS rate to legal minimum of " << MIN_TARGET_FPS << " frames per second." << std::endl;
            }
            if (theFpsLimit > MAX_TARGET_FPS)
            {
                theFpsLimit = MAX_TARGET_FPS;
                std::cout << "Limiting FPS rate to legal maximum of " << MAX_TARGET_FPS << " frames per second." << std::endl;
            }
 
            // ...then set it and calculate the target duration of each frame at this framerate
            targetFps = theFpsLimit;
            targetFrameDuration = 1.0 / targetFps;
        }
 
        double getFrameDuration() { return frameDuration; } // Returns the time it took to complete the last frame in milliseconds
 
        // Setter for the report interval (how often the FPS is reported) - santises input.
        void setReportInterval(float theReportInterval)
        {
            // Ensure the time interval between FPS checks is sane (low cap = 0.1s, high-cap = 10.0s)
            // Negative numbers are invalid, 10 fps checks per second at most, 1 every 10 secs at least.
            if (theReportInterval < 0.1)
            {
                theReportInterval = 0.1;
            }
            if (theReportInterval > 10.0)
            {
                theReportInterval = 10.0;
            }
            reportInterval = theReportInterval;
        }
 
        // Method to force our application to stick to a given frame rate and return how long it took to process a frame
        double enforceFPS()
        {
            // Get the current time
            frameEndTime = glfwGetTime();
 
            // Calculate how long it's been since the frameStartTime was set (at the end of this method)
            frameDuration = frameEndTime - frameStartTime;
 
            if (reportInterval != 0.0f)
            {
 
                // Calculate and display the FPS every specified time interval
                if ((frameEndTime - lastReportTime) > reportInterval)
                {
                    // Update the last report time to be now
                    lastReportTime = frameEndTime;
 
                    // Calculate the FPS as the number of frames divided by the interval in seconds
                    currentFps =  (double)frameCount / reportInterval;
 
                    // Reset the frame counter to 1 (and not zero - which would make our FPS values off)
                    frameCount = 1;
 
                    if (verbose)
                    {
                        std::cout << "FPS: " << currentFps << std::endl;
 
                        // If the user specified a window title to append the FPS value to...
                        if (windowTitle != "NONE")
                        {
                            // Convert the fps value into a string using an output stringstream
                            std::ostringstream stream;
                            stream << currentFps;
                            std::string fpsString = stream.str();
 
                            // Append the FPS value to the window title details
                            std::string tempWindowTitle = windowTitle + " | FPS: " + fpsString;
 
                            // Convert the new window title to a c_str and set it
                            const char* pszConstString = tempWindowTitle.c_str();
                            glfwSetWindowTitle(pszConstString);
                        }
 
                    } // End of if verbose section
 
                }
                else // FPS calculation time interval hasn't elapsed yet? Simply increment the FPS frame counter
                {
                    ++frameCount;
                }
 
            } // End of if we specified a report interval section
 
            // Calculate how long we should sleep for to stick to our target frame rate
            sleepDuration = targetFrameDuration - frameDuration;
 
            // If we're running faster than our target duration, sleep until we catch up!
            if (sleepDuration > 0.0)
                glfwSleep(targetFrameDuration - frameDuration);
 
            // Reset the frame start time to be now - this means we only need put a single call into the main loop
            frameStartTime = glfwGetTime();
 
            // Pass back our total frame duration (including any sleep and the time it took to run this function) to be used as our deltaTime value
            return frameDuration + (frameStartTime - frameEndTime);
 
        } // End of our enforceFPS method
 
};








//                                                                                                                          
//                          OPENGL 2.0 Abstraction API
//                               January 24 2018
//                              -----------------                                                                           
//                                                                                                                          
//                         OPEN_GL WINDOW MANAGEMENT LIB                                                                    
//==========================================================================================================================
//
// THIS FILE IS JUST USED TO TEST THE SYSTEM AND IS SUBJECT TO CHANGE ON A DAILY BASIS.



#include"window.h"
#include"3d_primitive.h"
#include"Shader.h"
#include"Renderer.h"
#include"Camera.h"
#include "glm.hpp"

//==========================================================================================================================
//                                                    MAIN 
//__________________________________________________________________________________________________________________________
//==========================================================================================================================

int main( int argc, char* args[] )
{
    float angle =0.0;
    float ZPos = 0.0,
          YPos = 0.0,
          XPos = 0.0;

    float CameraX=0,CameraY=0;

    float AngleX =0,
          AngleY =0,
          AngleZ =0;


    const int NumObjects = 5;
    vector<Torus> ObjectList;

   // Camera Camera1(SCREENWIDTH,SCREENHEIGHT);

    Window MainWindow(0,0,SCREENWIDTH, SCREENHEIGHT, "OpenGL 2.0");

    Print(glGetString(GL_EXTENSIONS));
    Print("OpenGL Version: " ; Print(glGetString(GL_VERSION)));
    Print( "Renderer: " ; Print(    glGetString(GL_RENDERER)  ));
    Print( "Current Context: " ; Print(wglGetCurrentContext()));
  
    float s = 0;

    for_loop(zcount, NumObjects){
         for_loop(ycount, NumObjects){
             for_loop(xcount, NumObjects){
                 s++;
                 Torus Temp =  Torus(8,25, xcount * 5, 
                                           ycount * 5,
                                           zcount * 5, 
                                            1);
                 Temp.Rotate(0,0,0);
                 ObjectList.push_back(Temp);

             }
         }
    }

Torus Temp =  Torus(8,25, 0,0,0,3);
                 Temp.Rotate(0, 0,0);
ObjectList.push_back(Temp);      

Matrix4 Cperspect = Matrix4::Perspective(30,640.0/480.0, 1, 1000);
 

Vec3 Eye(5.,-5.,8.);
Vec3 Look(3.,4.,0.);

Vec3 w = Eye - Look;
w.Normalize();



glm::vec3 a = Vec3ToGlm(Vec3(0,0,1));
glm::vec3 b = Vec3ToGlm(w);
glm::vec3  cu = glm::cross( a, b);
Vec3 u = GlmtoVec3(cu);
u.Normalize();



a = Vec3ToGlm(u);
b = Vec3ToGlm(w);
glm::vec3 cr = glm::cross( a, b); // up = side x look
Vec3 v = GlmtoVec3(cr);
v.Normalize();



Matrix4 rotation = Matrix4::Identity(); 
rotation.columns[0].x = u.x;
rotation.columns[1].x = u.y;
rotation.columns[2].x = u.z;

rotation.columns[0].y = v.x;
rotation.columns[1].y = v.y;
rotation.columns[2].y = v.z;

rotation.columns[0].z = w.x;
rotation.columns[1].z = w.y;
rotation.columns[2].z = w.z;


Matrix4 translation = Matrix4::Identity();
translation.columns[3].x = -Look.x;
translation.columns[3].y = -Look.y;
translation.columns[3].z = -Look.z;
//
 
Matrix4 view =  Matrix4::Identity();
//view = translation * rotation;
 view = rotation * translation;

// print matrix on console
cout << view << endl;
system("PAUSE");

//---------------------------------------------------------
     
    
    float MOVEX = 0;
    float MOVEY = 0, 
          OLDMX = 0, 
          OLDMY = 0,
          POSX  = 0, 
          POSY  = 0;
    
   while (GAME_LOOP())
   {
   CLS(); 

   if(SCREEN->KEY_BOARD.Key == GLFW_KEY_RIGHT)
   { 
       XPos += .1;
     //  Camera1.MoveRight(1);

   } 
   if(SCREEN->KEY_BOARD.Key == GLFW_KEY_LEFT)
   { 
       XPos -= .1;
   //  Camera1.MoveLeft(1);

   }
   if(SCREEN->KEY_BOARD.Key == GLFW_KEY_DOWN)
   { 
       ZPos -= .1; 
    //   Camera1.MoveBackward(1);
   }
   if(SCREEN->KEY_BOARD.Key == GLFW_KEY_UP) 
   {
       ZPos += .1;
    //   Camera1.MoveForward(1);
   }

   if(SCREEN->KEY_BOARD.Key == GLFW_KEY_SPACE) ;       



   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
  // glTranslatef(0,0,-50);
 // Get the MouseMovement 
   MOVEX = SCREEN->MOUSE.X - OLDMX;
   MOVEY = SCREEN->MOUSE.Y - OLDMY;
   OLDMX = SCREEN->MOUSE.X;
   OLDMY = SCREEN->MOUSE.Y;

// APPLY MouseMovement to the Camera Rotation
   CameraX += MOVEX;
   CameraY += MOVEY;
//Camera1.rotation.y += (MOVEX * .8);
//Camera1.rotation.x += (MOVEY * .8);
//Camera1.Rotate(CameraX,CameraY);
// Rotate the world

//   glRotatef(Camera1.rotation.z, 
//                            0.0,  
//                            0.0, 
//                            1.0);
//
//  glRotatef(Camera1.rotation.x, 
//                           1.0,  
//                           0.0, 
//                           0.0);
//
//  glRotatef(Camera1.rotation.y, 
//                           0.0,  
//                           1.0, 
//                           0.0);
//
//


//
// glTranslatef(Camera1.position.x,0,0);
// glTranslatef (0,Camera1.position.y, 0);
// glTranslatef(0.,0., Camera1.position.z);
// 

   for(int i = -500; i <= 500; i+=5)
   {
       glBegin(GL_LINES);
       glVertex3f(-500, 0, i);
       glVertex3f( 500, 0, i);
       glVertex3f(i, 0, -500);
       glVertex3f(i, 0,  500);
       glEnd();
   }

           glPushMatrix();
   for(Torus &List: ObjectList){

        List.Render();
    }
   
    glPopMatrix();

    SYNC();
    }
}





//const double Camera::TO_RADS = 3.141592654 / 180.0; // The value of 1 degree in radians
 
//TRANSLATION

//public void Move(Vector3D direction, double amount)
//{
//    Position += direction * amount;
//}
//ROTATION
//x = RotationAxis.x * sin(RotationAngle / 2)
//y = RotationAxis.y * sin(RotationAngle / 2)
//z = RotationAxis.z * sin(RotationAngle / 2)
//w = cos(RotationAngle / 2)
// https://www.codeproject.com/Articles/1170888/The-Flying-Camera

 /*

void Camera::Move(Vec3 direction, double amount)
{   
    Position += direction * amount;
}


Vec3  Camera::Transform(Vec4 q, Vec3 v)
{
    double x2 = q.x + q.x;
    double y2 = q.y + q.y;
    double z2 = q.z + q.z;
    double wx2 = q.w * x2;
    double wy2 = q.w * y2;
    double wz2 = q.w * z2;
    double xx2 = q.x * x2;
    double xy2 = q.x * y2;
    double xz2 = q.x * z2;
    double yy2 = q.y * y2;
    double yz2 = q.y * z2;
    double zz2 = q.y * z2;
    double x = v.x * (1.0 - yy2 - zz2) + v.y * (xy2 - wz2) + v.z * (xz2 + wy2);
    double y = v.x * (xy2 + wz2) + v.y * (1.0 - xx2 - zz2) + v.z * (yz2 - wx2);
    double z = v.x * (xz2 - wy2) + v.y * (yz2 + wx2) + v.z * (1.0 - xx2 - yy2);
    return  Vec3(x, y, z);
}

Vec4 q = new Vec4(axis, angle);
Vec3 rotated = q.Transform(v);

    Vec3  Camera::Rotate(  Vec3 v, Vec3 rotationAxis, double angleInDegrees)
{
    Vec4 q = new Vec4(rotationAxis, angleInDegrees);
    return q.Transform(v);
}
  void  Camera::ChangeYaw(double angle)
{
    LookDirection = LookDirection.Rotate(UpDirection, angle);
}
  void  Camera::ChangeRoll(double angle)
{
    UpDirection = UpDirection.Rotate(LookDirection, angle);
}
  void  Camera::ChangePitch(double angle)
{
    Vec4 q = Math3D.Rotation(LeftDirection, angle);
    UpDirection = q.Transform(UpDirection);
    LookDirection = q.Transform(LookDirection);
}
  void  Camera::ChangeHeading(double angle)
{
    Vec4 q = Math3D.RotationZ(angle);
    UpDirection = q.Transform(UpDirection);
    LookDirection = q.Transform(LookDirection);
}
  void  Camera::Rotate(Vec3 axis, double angle)
{
    Vec4 q = Math3D.Rotation(axis, angle);
    Position = q.Transform(Position);
    UpDirection = q.Transform(UpDirection);
    LookDirection = q.Transform(LookDirection);
}
  void  Camera::Rotate(Vec3 axis, double angle)
{
    Vec4 q = Math3D.Rotation(axis, angle);
    Position = q.Transform(Position);
    UpDirection = q.Transform(UpDirection);
    LookDirection = q.Transform(LookDirection);
}
    void  Camera::LookAt(Vec3 targetPoint, Vec3 observerPosition,   Vec3 &lookDirection,   Vec3 &upDirection)
{
    lookDirection = targetPoint - observerPosition;
    lookDirection.Normalize();

    double a = lookDirection.x;
    double b = lookDirection.y;
    double c = lookDirection.z;


    double length = (a * a + b * b);
    if (length > 1e-12)
    {
        upDirection = Vec3(-c * a / length, -c * b / length, 1);
        upDirection.Normalize();
    }
    else
    {
        if (c > 0)
            upDirection = UnitX;
        else
            upDirection = -UnitX;
    }
}

    void  Camera::OnKeyDown(KeyEventArgs e)
{
    base.OnKeyDown(e);

    //--- assume we are handling the key
    e.Handled = true;
    double amount = WFUtils.IsShiftDown() ? 1 : 0.2;

    if (WFUtils.IsCtrlDown())
    {
        amount *= WFUtils.IsAltDown() ? 0.1 : 0.5;
        amount *= Camera.Scale;
        switch (e.Key)
        {
            case Key.Up: Camera.Move(Camera.LookDirection, +amount); return;
            case Key.Down: Camera.Move(Camera.LookDirection, -amount); return;
            case Key.Left: Camera.Move(Camera.LeftDirection, +amount); return;
            case Key.Right: Camera.Move(Camera.LeftDirection, -amount); return;
            case Key.Prior: Camera.Move(Camera.UpDirection, +amount); return;
            case Key.Next: Camera.Move(Camera.UpDirection, -amount); return;
            default: e.Handled = false; return;
        }
    }

    switch (e.Key)
    {
        case Key.Up: Camera.ChangePitch(amount); return;
        case Key.Down: Camera.ChangePitch(-amount); return;
        case Key.Left: if (Camera.Speed == 0) Camera.ChangeYaw(amount); else Camera.ChangeRoll(-amount); return;
        case Key.Right: if (Camera.Speed == 0) Camera.ChangeYaw(-amount); else Camera.ChangeRoll(+amount); return;
        case Key.Prior: Camera.ChangeRoll(-amount); return;
        case Key.Next: Camera.ChangeRoll(+amount); return;
        case Key.W: Camera.Speed++; return;
        case Key.S: Camera.Speed--; return;
        case Key.X: Camera.Speed = 0; return;
        case Key.D1: ActivateCamera(0); return;
        case Key.D2: ActivateCamera(1); return;
        case Key.D3: ActivateCamera(2); return;
        default: e.Handled = false; return;
    }
}
    void  Camera::OnMouseMove(MouseEventArgs e)
{
    base.OnMouseMove(e);
    if (e.LeftButton != MouseButtonState.Pressed)
        return;

    Point position = e.GetPosition(this);

    if (prevPosition.IsValid())
        HandleMouseMove(prevPosition - position);

    prevPosition = position;
}

Vec2 prevPosition = new Point(double.NaN, 0);

  void  Camera::HandleMouseMove(Vec2 mouseMove)
{
    double factor = WFUtils.IsShiftDown() ? 0.5 : 0.1;
    double angleX = mouseMove.X * factor;
    double angleY = mouseMove.Y * factor;

    if (Camera.Speed == 0)
    {
        Camera.Rotate(Math3D.UnitZ, 2 * angleX);
        Camera.Rotate(Camera.RightDirection, 2 * angleY);
    }
    else
    {
        if (Camera.MovingDirectionIsLocked)
        {
            Camera.ChangeHeading(angleX);
            Camera.ChangePitch(angleY);
        }
        else
        {
            Camera.ChangeRoll(-angleX);
            Camera.ChangePitch(angleY);
        }
    }
}



}; */
    //--- Find the one and only up vector (x, y, z) which has a positive z value (1),
    //--- which is perpendicular to the look vector (2) and and which ensures that
    //--- the resulting roll angle is 0, i.e. the resulting left vector (= up cross look)
    //--- lies within the xy-plane (or has a z value of 0) (3). In other words:
    //--- 1. z > 0 (e.g. 1)
    //--- 2. ax + by + cz = 0
    //--- 3. ay - bx = 0
    //--- If the observer position is right above or below the target point, i.e. a = b = 0 and c != 0,
    //--- we set the up vector to (1, 0, 0) for c > 0 and to (-1, 0, 0) for c < 0. 






	
/*
class Camera{

public:
    void Move(Vec3 direction, double amount);

 static Vec3 Transform(Vec4 q, Vec3 v);
 
Vec3 Position;
Vec3 Up;
Vec3 Rotation;

//Quaternion q = new Quaternion(axis, angle);
//Vec3 rotated = q.Transform(v);

public:
    static Vec3 Rotate(  Vec3 v, Vec3 rotationAxis, double angleInDegrees);
 void ChangeYaw(double angle);
 void ChangeRoll(double angle);
 void ChangePitch(double angle);
 void ChangeHeading(double angle);
 void Rotate(Vec3 axis, double angle);
 void Rotate(Vec3 axis, double angle);
 static void LookAt(Vec3 targetPoint, Vec3 observerPosition,   Vec3 &lookDirection, Vec3 &upDirection);

 Vec3  Camera::Transform(Vec4 q, Vec3 v);

protected:
   void OnKeyDown(KeyEventArgs e);
   void OnMouseMove(MouseEventArgs e);
Vec2 prevPosition = new Point(double.NaN, 0);
 void HandleMouseMove(Vec2 mouseMove);

}; */


class Camera{
public:
    Camera(){}
    Vec3 Position;

    float Move_Speed;

    Vec3  Rotation;
    Vec3  Translation;


    void   MoveUp();
    void   MoveDown();
    void   MoveLeft();
    void   MoveRight();
    void   MoveForward();
    void   MoveBackward();

};


//void Camera::MoveUp(){
//}
//
//void Camera::MoveDown(){
//}
//
//void Camera::MoveLeft(){
//}
//
//void Camera::MoveRight(){
//}
//
//void Camera::MoveForward(){
//    Position.x += Move_Speed;
//    Position.y += Move_Speed;
//    Position.z += Move_Speed;
//}
//
//void Camera::MoveBackward(){
//    Position.x -= Move_Speed;
//    Position.y -= Move_Speed;
//    Position.z -= Move_Speed;
//}
//
//


#endif // CAMERA_H




/// 1500

///float sinXRot = sin( toRads( rotation.x ) );
//float cosXRot = cos( toRads( rotation.x ) );
///
//float sinYRot = sin( toRads( rotation.y ) );
//float cosYRot = cos( toRads( rotation.y ) );
///
//float pitchLimitFactor = cosXRot; // This cancels out moving on the Z axis when we're looking up or down
///
///movement.x+=(sinYRot * pitchLimitFactor);
///movement.y+=(-sinXRot);
///movement.z+=(-cosYRot * pitchLimitFactor);




SPHERE DRAWING ROUTINES THAT FAILED OR UNDERPERFORMED

//Sphere::Sphere(float R, float H, float K, float Z) 
//{
//int space = 100;
//double a=0;
//double b=0;
//
// //   List = glGenLists(1);
// //  glNewList(List, GL_COMPILE);
// //
// //   for( b = 0; b <= (90 - space); b+=space){
// //              glBegin(GL_QUADS);
// //           for( a = 0; a <= 360 - space; a+=space){
// //
// //                   glVertex3f( R * sin((RADIANS(a))) * sin((RADIANS(b)) ) - H,
// //                               R * cos((RADIANS(a))) * sin((RADIANS(b)) ) + K,
// //                               R * cos((RADIANS(b))) - Z);
// //                    
// //                   
// //                   glVertex3f (R * sin((RADIANS(a))) * sin((RADIANS(b + space)) ) - H,
// //                               R * cos((RADIANS(a))) * sin((RADIANS(b + space))) + K,
// //                               R * cos((RADIANS(b )+ space)) - Z);
// //                               
// //                   glVertex3f( R * sin((RADIANS(a) + space)) * sin((RADIANS(b)) ) - H,
// //                               R * cos((RADIANS(a) + space)) * sin((RADIANS(b))) + K,
// //                               R * cos((RADIANS(b))) - Z);
// //                                
// //                   glVertex3f( R * sin((RADIANS(a + space)) ) * sin((RADIANS(b + space)) ) - H,
// //                               R * cos((RADIANS(a + space)) ) * sin((RADIANS(b + space))) + K,
// //                               R * cos((RADIANS(b + space)) ) - Z);
// //           }
// //                   glEnd();
// //   }
// //
// //    glEndList(); 
// //   
//}
//

//Sphere::Sphere(float X,float Y,float Z,float radius){
////x = r * sin(Lat) * cos(lat)
////y = r * sin(Lat) * sin(lon)
////z = r * cos(Lat)
//
////r = radius
////lat = the angle down from the north pole
////lon = Longitude East from Prime Meridian
//float x,y,z;
//   glNewList(List, GL_COMPILE);
//    for(float Long =0;Long < 360;Long+=10){
//        glBegin(GL_POINTS);
//        for(float Lat =0;Lat < 360;Lat+=10){
//            x = radius * sin(RADIANS(Lat)) * cos(RADIANS(Lat));
//            y = radius * sin(RADIANS(Lat)) * sin(RADIANS(Long));
//            z = radius * cos(RADIANS(Lat));
//            glVertex3f(x + X, y + Y, z + Z);
//        }
//        glEnd();
//    }
//    glEndList();
//}


SolidSphere::SolidSphere(float radius, unsigned int rings, unsigned int sectors)
{
    float const R = 1./(float)(rings-1);
    float const S = 1./(float)(sectors-1);
    int r, s;
    float X,Y,Z;
    
    for(r = 0; r < rings; r++) for(s = 0; s < sectors; s++) {
        float const y = sin( -M_PI_2 + M_PI * r * R );
        float const x = cos(2*M_PI * s * S) * sin( M_PI * r * R );
        float const z = sin(2*M_PI * s * S) * sin( M_PI * r * R );
            X = x * radius;
            Y = y * radius;
            Z = z * radius;

        glBegin(GL_TRIANGLES);
        glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));

        glVertex3f(X,Y,Z);
        glNormal3f(X,Y,Z);
        glEnd();
   }
}




//Sphere::Sphere(float X,float Y, float Z, float radius){
// 
//        float x=0,y=0,z=0;
//        float x1=0,y1=0,z1=0;
//        float x2=0,y2=0,z2=0;
//        float x3=0,y3=0,z3=0;
//
//        Position.x = X;
//        Position.y = Y;
//        Position.z = Z;
//
//        glPushMatrix();
//        float size = 2;
//    for(float Long =0;Long < 180;Long+=size){
//        glBegin(GL_TRIANGLE_STRIP);
//        for(float Lat =0;Lat < 360;Lat+=size){
//            x = radius * (sin(RADIANS(Lat)) * cos(RADIANS(Long)));
//            y = radius *( sin(RADIANS(Lat)) * sin(RADIANS(Long)));
//            z = radius * cos(RADIANS(Lat));
//
//            x1 = radius *( sin(RADIANS(Lat + size)) * cos(RADIANS(Long)));
//            y1 = radius * (sin(RADIANS(Lat + size)) * sin(RADIANS(Long)));
//            z1 = radius * cos(RADIANS(Lat + size));
//
//            x2 = radius * (sin(RADIANS(Lat)) * cos(RADIANS(Long+size)));
//            y2 = radius * (sin(RADIANS(Lat)) * sin(RADIANS(Long+size)));
//            z2 = radius * cos(RADIANS(Lat));
//
//            x3 = radius * (sin(RADIANS(Lat+ size )) * cos(RADIANS(Long+ size)));
//            y3 = radius * (sin(RADIANS(Lat+ size)) * sin(RADIANS(Long+ size)));
//            z3 = radius * cos(RADIANS(Lat+ size));
//
//
//           // glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
//            glVertex3f(x + 10, y + 10, z + 10);
//
//          //  glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
//            glVertex3f(x1 + 10, y1 + 10, z1 + 10);
//
//           // glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
//            glVertex3f(x2 + 10, y2 + 10, z2 + 10);
//            glVertex3f(x3 + 10, y3 + 10, z3 + 10);
//        }
//               glEnd();
//    }
//}
//
//
//
//
//------------------- PROGRAMABLE PIPELINE VERTEX SHADER ---------------------------
//
//   uniform mat4 worldToCamMatrix, projMatrix; 
//
//   in vec3 vert; 
// 
//   void main() 
//   { 
//       gl_Position = projMatrix * worldToCamMatrix * vec4(vert, 1); 
//   } 
//
//



// Identity 
//  gluLookAt( x, 1, z,
//      x+Lx, 1,z+Lz,
//      0,1,0)
//
//  Render


  //  glBegin(GL_LINES);
  //      glVertex3f(-100.0f , 0.0, -100.0f);
  //      glVertex3f(-100.0f , 0.0,  100.0f);
  //      glVertex3f( 100.0f , 0.0,  100.0f);
  //      glVertex3f( 100.0f , 0.0, -100.0f);
  //  glEnd();


// gluLookAt(Camera1.rotation.x,
//           Camera1.rotation.y,
//           Camera1.rotation.z,
//
//           Camera1.position.x,
//           Camera1.position.y,
//           Camera1.position.z, 
//
//           Camera1.Up.x,
//           Camera1.Up.y,
//           Camera1.Up.z);
//
     
//   glTranslatef(XPos, 0.0, 0.0);
//   glTranslatef(0.0, YPos, 0.0);
//   glTranslatef(0.0, 0.0, ZPos);
//   
//   glRotatef(CameraY / 2, 
//                     1.0,
//                     0.0, 
//                     0.0);
//   
//   glRotatef(CameraX / 2,  
//                     0.0,
//                     1.0,
//                     0.0);
//                     
//   glRotatef(CameraX / CameraY,  
//                     0.0,
//                     0.0,
//                     1.0);
//







//   Matrix4 rotation = Matrix4::Identity(); 
//   rotation.columns[0].x = u.x;
//   rotation.columns[0].Y = u.y;
//   rotation.columns[0].Z = u.z;
//   
//   rotation.columns[1].X = v.x;
//   rotation.columns[1].y = v.y;
//   rotation.columns[1].Z = v.z;
//   
//   rotation.columns[2].X = w.x;
//   rotation.columns[2].z = w.y;
//   rotation.columns[2].z = w.z;


   //     float radius = 2;
   //     float x=0,y=0,z=0;
   //     float x1=0,y1=0,z1=0;
   //     float x2=0,y2=0,z2=0;
   //     float x3=0,y3=0,z3=0;
   //     glPushMatrix();
   //     float size = 2;
   // for(float Long =0;Long < 180;Long+=size){
   //     glBegin(GL_TRIANGLE_STRIP);
   //     for(float Lat =0;Lat < 360;Lat+=size){
   //         x = radius * (sin(RADIANS(Lat)) * cos(RADIANS(Long)));
   //         y = radius *( sin(RADIANS(Lat)) * sin(RADIANS(Long)));
   //         z = radius * cos(RADIANS(Lat));
   //
   //         x1 = radius *( sin(RADIANS(Lat + size)) * cos(RADIANS(Long)));
   //         y1 = radius * (sin(RADIANS(Lat + size)) * sin(RADIANS(Long)));
   //         z1 = radius * cos(RADIANS(Lat + size));
   //
   //         x2 = radius * (sin(RADIANS(Lat)) * cos(RADIANS(Long+size)));
   //         y2 = radius * (sin(RADIANS(Lat)) * sin(RADIANS(Long+size)));
   //         z2 = radius * cos(RADIANS(Lat));
   //
   //         x3 = radius * (sin(RADIANS(Lat+ size )) * cos(RADIANS(Long+ size)));
   //         y3 = radius * (sin(RADIANS(Lat+ size)) * sin(RADIANS(Long+ size)));
   //         z3 = radius * cos(RADIANS(Lat+ size));
   //
   //
   //        // glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
   //         glVertex3f(x + 10, y + 10, z + 10);
   //
   //       //  glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
   //         glVertex3f(x1 + 10, y1 + 10, z1 + 10);
   //
   //        // glColor3f(GL_Color(x* 255.0),GL_Color(y* 255.0),GL_Color(z * 255.0));
   //         glVertex3f(x2 + 10, y2 + 10, z2 + 10);
   //         glVertex3f(x3 + 10, y3 + 10, z3 + 10);
   //     }
   //            glEnd();
   // }
   //
 
     //   glPopMatrix();
//
//  for(int i = -500; i <= 500; i+=5)
//  {
//      glBegin(GL_LINES);
//      glVertex3f(-500,100, i);
//      glVertex3f( 500, 100, i);
//      glVertex3f(i, 100, -500);
//      glVertex3f(i, 100,  500);
//      glEnd();
//  }
//
//   for(int i = -500; i <= 500; i+=5)
//   {
//       glBegin(GL_LINES);
//       glVertex3f(-500,400, i);
//       glVertex3f( 500, 400, i);
//       glVertex3f(i, 400, -500);
//       glVertex3f(i, 400,  500);
//       glEnd();
//   }
//
//      for(int i = -500; i <= 500; i+=5)
//   {
//       glBegin(GL_LINES);
//       glVertex3f(-500,-100, i);
//       glVertex3f( 500, -100, i);
//       glVertex3f(i, -100, -500);
//       glVertex3f(i, -100,  500);
//       glEnd();
//   }
//
// for(int i = -500; i <= 500; i+=5)
//   {
//       glBegin(GL_LINES);
//       glVertex3f(-500,-400, i);
//       glVertex3f( 500, -400, i);
//       glVertex3f(i, -400, -500);
//       glVertex3f(i, -400,  500);
//       glEnd();
//   }





//=====================================================================================================================================
                                   4/11 3D Primative, Sphere class
//=====================================================================================================================================


               Vertices[vertex_count]     =  x + 10;
               Vertices[vertex_count+1]   =  y + 10;
               Vertices[vertex_count+2]   =  z + 10;
               
               Vertices[vertex_count + 3] =  x1 + 10;
               Vertices[vertex_count + 4] =  y1 + 10;
               Vertices[vertex_count + 5] =  z1 + 10;
               
               Vertices[vertex_count + 6] =  x2 + 10;
               Vertices[vertex_count + 7] =  y2 + 10;
               Vertices[vertex_count + 8] =  z2 + 10;
               
               Vertices[vertex_count + 9]  =  x3 + 10;
               Vertices[vertex_count + 10] =  y3 + 10;
               Vertices[vertex_count + 11] =  z3 + 10;
               
               vertex_count += (4 * 3);

			   


//glBindBuffer(GL_ARRAY_BUFFER, BufferID);
//glVertexPointer( 3, GL_FLOAT, 0, (char *) NULL);
//glEnableClientState(GL_VERTEX_ARRAY);
//glDrawArrays(GL_TRIANGLES, 0, 6);


// glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices),  Vertices, GL_STATIC_DRAW); //<-------------------------


//
//
//
//
//  glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID);
//  glEnableVertexAttribArray(0);    // We like submitting vertices on stream 0 for no special reason
//  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float), BUFFER_OFFSET(0));      // The starting point of the VBO, for the vertices
//  //glEnableVertexAttribArray(1);    // We like submitting normals on stream 1 for no special reason
//  //glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(MyVertex), BUFFER_OFFSET(12));     // The starting point of normals, 12 bytes away
//  //glEnableVertexAttribArray(2);    // We like submitting texcoords on stream 2 for no special reason
//  //glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(MyVertex), BUFFER_OFFSET(24));     // The starting point of texcoords, 24 bytes away
//  
//  glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID);
//  // To render, we can either use glDrawElements or glDrawRangeElements
//  // The is the number of indices. 3 indices needed to make a single triangle
//  //glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, BUFFER_OFFSET(0));    // The starting point of the IBO
//glDrawArrays(GL_TRIANGLE_STRIP, BUFFER_ID, VertexCount);
//  
//  glBindBuffer(GL_ARRAY_BUFFER, 0);
//

//
//Print(sizeof(Vertices));
//
//  glGenBuffersARB(1, &BUFFER_ID);
//  glBindBufferARB(GL_ARRAY_BUFFER, BUFFER_ID);
//  glGenBuffersARB(1 , &BUFFER_ID);
//
//  glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID);
//  glBufferData(GL_ARRAY_BUFFER, 3,  Vertices, GL_STATIC_DRAW); //<-------------------------
//  glBindBuffer(GL_ARRAY_BUFFER,0);        


// ______________________________________________________________
// NOTE:: 646 Vetices in Buffer When draw as normal array
//         Vcount reaches  648
//         vertex_count reaches 1944
// ______________________________________________________________

   VertexCount = vcount; //vertex_count;
  //  glGenBuffersARB(1, &BUFFER_ID);
  //  glBindBufferARB(GL_ARRAY_BUFFER, BUFFER_ID);

   // Buffer(GLfloat *data,GLsizei count,GLint componentcount)
    Print(sizeof(float));
    Print(sizeof(Vec3));
    Print(sizeof(vec3Vert));
    Print(sizeof(Vertices));


      //Balls.Render();
     // Balls.ChangeVerts();
    //  glFlush();

   // for(Mesh &List: ObjectList)
   // {
   //       List.Render();
   //  }
   



  //  vertices.resize(rings * sectors * 3);
  //  normals.resize(rings * sectors * 3);
  //  texcoords.resize(rings * sectors * 2);
  //
  //  std::vector<GLfloat>::iterator v = vertices.begin();
  //  std::vector<GLfloat>::iterator n = normals.begin();
  // std::vector<GLfloat>::iterator t = texcoords.begin();



//
//
//#define _USE_MATH_DEFINES
//#include"Window.h"
//
//// your framework of choice here
//
//class SolidSphere
//{
//protected:
//    std::vector<GLfloat> vertices;
//    std::vector<GLfloat> normals;
//    std::vector<GLfloat> texcoords;
//    std::vector<GLushort> indices;
//
//public:
//    SolidSphere(float radius, unsigned int rings, unsigned int sectors)
//    {
//        float const R = 1./(float)(rings-1);
//        float const S = 1./(float)(sectors-1);
//        int r, s;
//
//        vertices.resize(rings * sectors * 3);
//        normals.resize(rings * sectors * 3);
//        texcoords.resize(rings * sectors * 2);
//        std::vector<GLfloat>::iterator v = vertices.begin();
//        std::vector<GLfloat>::iterator n = normals.begin();
//        std::vector<GLfloat>::iterator t = texcoords.begin();
//        for(r = 0; r < rings; r++) for(s = 0; s < sectors; s++) {
//                float const y = sin( -M_PI_2 + M_PI * r * R );
//                float const x = cos(2*M_PI * s * S) * sin( M_PI * r * R );
//                float const z = sin(2*M_PI * s * S) * sin( M_PI * r * R );
//
//                *t++ = s*S;
//                *t++ = r*R;
//
//                *v++ = x * radius;
//                *v++ = y * radius;
//                *v++ = z * radius;
//
//                *n++ = x;
//                *n++ = y;
//                *n++ = z;
//        }
//
//        indices.resize(rings * sectors * 4);
//        std::vector<GLushort>::iterator i = indices.begin();
//        for(r = 0; r < rings-1; r++) for(s = 0; s < sectors-1; s++) {
//                *i++ = r * sectors + s;
//                *i++ = r * sectors + (s+1);
//                *i++ = (r+1) * sectors + (s+1);
//                *i++ = (r+1) * sectors + s;
//        }
//    }
//
//    void draw(GLfloat x, GLfloat y, GLfloat z)
//    {
//        glMatrixMode(GL_MODELVIEW);
//        glPushMatrix();
//        glTranslatef(x,y,z);
//
//        glEnableClientState(GL_VERTEX_ARRAY);
//        glEnableClientState(GL_NORMAL_ARRAY);
//        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
//
//        glVertexPointer(3, GL_FLOAT, 0, &vertices[0]);
//        glNormalPointer(GL_FLOAT, 0, &normals[0]);
//        glTexCoordPointer(2, GL_FLOAT, 0, &texcoords[0]);
//        glDrawElements(GL_QUADS, indices.size(), GL_UNSIGNED_SHORT, &indices[0]);
//        glPopMatrix();
//    }
//};
//
//SolidSphere sphere(1, 12, 24);
//
//void display()
//{
//    int const win_width  = …; // retrieve window dimensions from
//    int const win_height = …; // framework of choice here
//    float const win_aspect = (float)win_width / (float)win_height;
//
//    glViewport(0, 0, win_width, win_height);
//
//    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//
//    glMatrixMode(GL_PROJECTION);
//    glLoadIdentity();
//    gluPerspective(45, win_aspect, 1, 10);
//
//    glMatrixMode(GL_MODELVIEW);
//    glLoadIdentity();
//
//#ifdef DRAW_WIREFRAME
//    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
//#endif
//    sphere.draw(0, 0, -5);
//
//    swapBuffers();
//}
//
//int main(int argc, char *argv[])
//{
//    // initialize and register your framework of choice here
//    return 0;
//}
//
//
//












                  

                                            
/*void glVertexAttribPointer(	GLuint index,
 	GLint size,
 	GLenum type,
 	GLboolean normalized,
 	GLsizei stride,
 	const GLvoid * pointer);*/






/*
Vertex_buffer_object::Vertex_buffer_object()
{
    initVB();
}
 
Vertex_buffer_object::~Vertex_buffer_object() {}
 
void Vertex_buffer_object::draw()
{
    glEnable(GL_DEPTH_TEST);
 
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
 
    glPushMatrix();
 
    glBindVertexArray(_vao);
 
    // bind buffer storing positions
    glBindBuffer(GL_ARRAY_BUFFER, _positionVBO);
    glEnableClientState(GL_VERTEX_ARRAY);
 
    // take positions from buffer bound to GL_ARRAY_BUFFER
    // this command 'remembers' which buffer is bound to
    // GL_ARRAY_BUFFER at the time of the call
    glVertexPointer(3, GL_FLOAT, 0, 0);
 
    // bind buffer storing normals
    // this has no effect on which buffer the positions are taken from
    glBindBuffer(GL_ARRAY_BUFFER, _normalVBO);
    glEnableClientState(GL_NORMAL_ARRAY);
    glNormalPointer(GL_FLOAT, 0, 0);
 
    // bind buffer storing colors
    glBindBuffer(GL_ARRAY_BUFFER, _colorVBO);
    glEnableClientState(GL_COLOR_ARRAY);
    glColorPointer(3, GL_UNSIGNED_BYTE, 0, NULL);
 
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexVBO);
 
    glEnableClientState(GL_ELEMENT_ARRAY_BUFFER);
 
    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
 
    glBindVertexArray(0);
 
    //desabilitando modos de desenho.
    glDisableClientState(GL_ELEMENT_ARRAY_BUFFER);
    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_NORMAL_ARRAY);
    glDisableClientState(GL_COLOR_ARRAY);
 
    //desabilitando vertex buffer
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}
 
void Vertex_buffer_object::initVB()
{
    if (!glGenBuffers || !glBindBuffer || !glBufferData)
    {
        std::cerr << "VBOs are not supported by your graphics card" << std::endl;
    }
 
 
    // Variables for the cube data
    float _vertex[] =
    {
        // front
        -1.0, -1.0,  1.0,
        1.0, -1.0,  1.0,
        1.0,  1.0,  1.0,
        -1.0,  1.0,  1.0,
        // back
        -1.0, -1.0, -1.0,
        1.0, -1.0, -1.0,
        1.0,  1.0, -1.0,
        -1.0,  1.0, -1.0,
    };
 
    float _normal[] = {((-1.0f, -1.0f, 1.0f),
                        ( 1.0f, -1.0f, 1.0f),
                        ( 1.0f, 1.0f, 1.0f),
                        (-1.0f, 1.0f, 1.0f),
                        (-1.0f, -1.0f, -1.0f),
                        (1.0f, -1.0f, -1.0f),
                        (1.0f, 1.0f, -1.0f),
                        (-1.0f, 1.0f, -1.0f))
                      };
 
    static const GLsizeiptr ColorSize = 8 * 3 * sizeof(GLubyte);
    static const GLubyte _color[] =
    {
        255,   0,   0,
        255, 255,   0,
        0, 255,   0,
        0, 255,   0,
        0,   0, 255,
        255,   0,   0,
        255, 255,   0,
        0, 255,   0
    };
    // Element Indicies for the Cube
    unsigned int _index[] =
    {
        // front
        0, 1, 2,
        2, 3, 0,
        // top
        3, 2, 6,
        6, 7, 3,
        // back
        7, 6, 5,
        5, 4, 7,
        // bottom
        4, 5, 1,
        1, 0, 4,
        // left
        4, 0, 3,
        3, 7, 4,
        // right
        1, 5, 6,
        6, 2, 1,
    };
 
    const unsigned _vertexSize = 24;
 
    glGenVertexArrays(1, &_vao);
    glBindVertexArray(_vao);
 
    //gerando a vbo para as posições
    glGenBuffers(1, &_positionVBO);
    glBindBuffer(GL_ARRAY_BUFFER, _positionVBO);
    glBufferData(GL_ARRAY_BUFFER, _vertexSize * sizeof(float), NULL, GL_STATIC_DRAW);
    void* positionPtr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
    memcpy(positionPtr, (float*) _vertex, 24 * sizeof(float));
    glUnmapBuffer(GL_ARRAY_BUFFER);
 
    //gerando a vbo para as normais
    glGenBuffers(1, &_normalVBO);
    glBindBuffer(GL_ARRAY_BUFFER, _normalVBO);
    glBufferData(GL_ARRAY_BUFFER, 24 * sizeof(float) , NULL, GL_STATIC_DRAW);
    void* normalPtr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
    memcpy(normalPtr, (float*) _normal, 24 * sizeof(float));
    glUnmapBuffer(GL_ARRAY_BUFFER);
 
    //gerando a vbo para as cores
    glGenBuffers(1, &_colorVBO);
    glBindBuffer(GL_ARRAY_BUFFER, _colorVBO);
    glBufferData(GL_ARRAY_BUFFER, ColorSize , NULL, GL_STATIC_DRAW);
    void* colorPtr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
    memcpy(colorPtr, (GLubyte*) _color, ColorSize);
    glUnmapBuffer(GL_ARRAY_BUFFER);
 
    //gerando a vbo para os indices
    glGenBuffers(1, &_indexVBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexVBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 36 * sizeof(unsigned int), NULL, GL_STATIC_DRAW);
 
    //setando os dados para index
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexVBO);
    void* indexPtr = glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_WRITE_ONLY);
    memcpy(indexPtr,(unsigned int*) _index,  36 * sizeof(unsigned int));
    glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
 
    glBindVertexArray(0);
}

*/






// RENDERER.CPP/H

//class Buffer{
//public:
//        Buffer();
//       ~Buffer();
//        Buffer(GLfloat *data,GLsizei count,GLint componentcount);
//        
//        void Bind();
//        void Unbind();
//public:
//        inline GLuint Get_Component(){return NUM_COMPONENTS;}
//        inline GLint Get_Count(){return COUNT;}
//private:
//        GLuint COUNT;
//        GLuint BUFFER_ID;
//        GLuint NUM_COMPONENTS; //How many vertex per count
//};

//Buffer::Buffer(){} ; Buffer::~Buffer(){}
//
//Buffer::Buffer(GLfloat *data,GLsizei count,GLint componentcount)
//    :NUM_COMPONENTS(componentcount), 
//     COUNT(count)
//{
//        _GL(glGenBuffersARB(1,&BUFFER_ID));                                                //Allocate memory and Assign Pointer to BUFFER_ID
//        _GL(glBindBuffer(GL_ARRAY_BUFFER,BUFFER_ID));                                   //Bind the Data to the BUFFER ID so it points to it
//        _GL(glBufferData(GL_ARRAY_BUFFER,count * sizeof(GLfloat),data,GL_STATIC_DRAW)); //<------------------------------------------------
//        _GL(glBindBuffer(GL_ARRAY_BUFFER,0));                                           // DELETE BUFFER since its now bound to the ID;
//}
//        
//void Buffer::Bind(){
//        _GL(glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID));
//}
//
//void Buffer::Unbind(){
//        _GL(glBindBuffer(GL_ARRAY_BUFFER,0));
//}
//





// PRIMATIVE.H

//       glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID[1]);
//           glColorPointer(3,GL_FLOAT,0,(char *) NULL);
//               glEnableClientState(GL_COLOR_ARRAY);
//
//       glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID[0]);
//           glVertexPointer( 3, GL_FLOAT, 0, (char *) NULL);
//               glEnableClientState(GL_VERTEX_ARRAY);
//                   glDrawArrays(GL_TRIANGLE_STRIP, 0, VertexCount);
//               glDisableClientState(GL_VERTEX_ARRAY);
//               glDisableClientState(GL_COLOR_ARRAY);
//       glBindBuffer(GL_ARRAY_BUFFER,0);

//Buffer::Buffer(GLfloat *data,GLsizei count,GLint componentcount)
//glGenBuffersARB(1,&BUFFER_ID));                                                //Allocate memory and Assign Pointer to BUFFER_ID
//glBindBuffer(GL_ARRAY_BUFFER,BUFFER_ID));                                   //Bind the Data to the BUFFER ID so it points to it
//glBufferData(GL_ARRAY_BUFFER,count * sizeof(GLfloat),data,GL_STATIC_DRAW)); //<------------------------------------------------
//glBindBuffer(GL_ARRAY_BUFFER,0));    

Primative.CPP

    glGenBuffers(2 , &BUFFER_ID[0]);
    glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID[0]);
        glBufferData(GL_ARRAY_BUFFER,VertexCount * sizeof(Vec3), Vertices, GL_STATIC_DRAW) ; 
    glBindBuffer(GL_ARRAY_BUFFER,0);         // Unbind BUFFER_ID since its now bound to the ID;

    glBindBuffer(GL_ARRAY_BUFFER, BUFFER_ID[1]); // Bind our second Vertex Buffer Object  
        glBufferData(GL_ARRAY_BUFFER, ColorCount * sizeof(RGBf), Colors, GL_STATIC_DRAW); // Set the size and data of our VBO and set it to STATIC_DRAW  
        glVertexAttribPointer((GLuint)1, 3, GL_FLOAT, GL_FALSE, 0, 0); // Set up our vertex attributes pointer  
            glEnableVertexAttribArray(1); 
    glBindBuffer(GL_ARRAY_BUFFER,0);         // Unbind BUFFER_ID since its now bound to the ID;




//==============================================================================================================================================
                                         THIS CODE IS TO PLACE AN OBJECT IN FRONT OF THE CAMERA 100 PACES...
										 THIS IS THE RAYCASTING CODE THAT WITHOUT A DOUBT NEEDS WORK
										 HOWEVER DO NOT FUCKING LOSE THIS AGAIN                                                                                                              
//==============================================================================================================================================
//______________________________________________________________________________________________________________________________________________
	
   Vec3   newposition = Cam.Position, 
                  rot = Cam.Rotation;

        newposition.x = -Cam.Position.x;
        newposition.y = -Cam.Position.y;
        newposition.z = -Cam.Position.z;

        newposition = Vec3::RayCast(newposition, rot, 100);

        RenderGrid();
        for(Ball &List:BallList){

        //  Vec3 pos = List.Get_Position();

        List.Set_Position(newposition);
            List.Render();
        }
//______________________________________________________________________________________________________________________________________________
//==============================================================================================================================================
//==============================================================================================================================================









        //  Vec3 pos = List.Get_Position();

         // pos.x += RANDOM(10)-5;
         // pos.y += RANDOM(10)-5;    
         // pos.z += RANDOM(10)-5;    
         // List.Set_Position(pos);
        //  List.Update();

        // for_loop(count, List.VertexCount){
        //     Vec3 Verts = List.Vertices[count];
        //      List.Vertices[count].x 
        //      List.Vertices[count].y         
        //      List.Vertices[count].z 
        //
        //    List.ChangeVert(count, List.Vertices[count]);
        //    List.Submit(List.Vertices);
    // for(Mesh &List: ObjectList)
    // {
    //     List.Render();
    // }

     // Print(Cam.Position.x;Print("   Y:"; Print(Cam.Position.y)));

 //
 // for_loop(zcount, NumObjects){
 //      for_loop(ycount, NumObjects){
 //          for_loop(xcount, NumObjects){
 //              Torus Temp =  Torus(8,25,(float)(xcount  * rand()%100), 
 //                                       (float)(ycount  * rand()%100),
 //                                       (float)(zcount  * rand()%100), 
 //                                                                   1);
 //              ObjectList.push_back(Temp);
 //                      Ball temp = Ball(Vec3(rand()%1000,
 //                                            rand()%1000,
 //                                            rand()%1000),
 //                                            rand()%10, 20);
 //     BallList.push_back(temp);
 //          }
 //              Mesh Temps =  Sphere(Vec3((float)(rand()%100),
 //                                        (float)(rand()%100),
 //                                        (float)(rand()%100)),
 //                                                          RANDOM(5));
 //              ObjectList.push_back(Temps);
 //      }
 //
 // }
 //




 
//class AABB{
//public: 
//    AABB(Vec2 points);
//
//    struct boundingbox{
//        Vec3 Corners[8];
//        void Set(Vec3 pos, float size);
//    }BoundingBox;
//
//    struct{
//        Vec3 Location;
//        float Radius;
//        void Set(Vec3 pos, float radius);
//    }BoundingSphere;
//
//    void Merge(AABB other){
//	     // const minA:Vector2 = a.m_centre.Sub( a.m_halfExtents );
//	     // const maxA:Vector2 = a.m_centre.Add( a.m_halfExtents );
//         // 
//	     // const minB:Vector2 = b.m_centre.Sub( b.m_halfExtents );
//	     // const maxB:Vector2 = b.m_centre.Add( b.m_halfExtents );
//         // 
//	     // const min:Vector2 = minA.Min(minB);
//	     // const max:Vector2 = maxA.Max(maxB);
//         // 
//	     // const centre:Vector2 = min.Add(max).MulScalar(0.5);
//	     // const halfExtents:Vector2 = max.Sub(min).MulScalar(0.5);
//         // 
//	     // return new AABB( centre, halfExtents );
//    }
//
//
//    static void Merge(AABB first, AABB second);
//};
//
////typedef AABB::Box::Se  Boxes;
// void AABB::boundingbox::Set(Vec3 pos, float size)
//{
//    Corners[0].x = pos.x + size;
//    Corners[0].y = pos.y + size;
//    Corners[0].z = pos.z + size;
//
//}
//

   


     // float nx = c * e * CamX - c * f * CamY + d * CamZ;
     // float ny = (a * f + b * d * e) * CamX + (a * e - b * d * f) * CamY - b * c * CamZ;
     // float nz = (b * f - a * d * e) * CamX + (a * d * f + b * e) * CamY + a * c * CamZ;


	 // https://r3dux.org/2012/12/a-c-camera-class-for-simple-opengl-fps-controls/



	 



// TODO:
////---------------------------- Static Resolution ------------------------------------------------------------------------------------------------------
//
////-----------------------------------------------------------------------------------------------------------------------------------------------------
//                SET_DRAW_COLOR(RGB(255,0,0)); // DRAW THE LINE SHOWING COLLISION
//                LINE( Body.Position.X , Body.Position.Y,  B2->Body.Position.X ,  B2->Body.Position.Y);
//                SET_DRAW_COLOR(RGB(255,255,255));
//                Ball::CollisionList.emplace_back(this, B2);
////-----------------------------------------------------------------------------------------------------------------------------------------------------
//                //float Momentum = 
//#if 0                 
//                    float NormalX = (B2->Body.Position.X - Body.Position.X) / Distance;
//                    float NormalY = (B2->Body.Position.Y - Body.Position.Y) / Distance;
//
//                    float TangentX = -NormalY;
//                    float TangentY =  NormalX;
//
//                    float dpTan1 = (Body.Velocity.X     * TangentX) + (Body.Velocity.Y     * TangentY);
//                    float dpTan2 = (B2->Body.Velocity.X * TangentX) + (B2->Body.Velocity.Y * TangentY);
//
//                    float dbNormal1 = (Body.Velocity.X     * NormalX) + (Body.Velocity.Y     * NormalY);
//                    float dbNormal2 = (B2->Body.Velocity.X * NormalX) + (B2->Body.Velocity.Y * NormalY);
//                          
//                    float M1 = (dbNormal1 * (Body.Kg     - B2->Body.Kg) + 2.0f * B2->Body.Kg * dbNormal2) / (Body.Kg + B2->Body.Kg );
//                    float M2 = (dbNormal2 * (B2->Body.Kg -     Body.Kg) + 2.0f * Body.Kg     * dbNormal1) / (Body.Kg + B2->Body.Kg) ;
//
//
//                        Body.Velocity.X = TangentX  * dpTan1  + NormalX  * M1;
//                        Body.Velocity.Y = TangentY  * dpTan1  + NormalY  * M1;
//                    B2->Body.Velocity.X = TangentX  * dpTan2  + NormalX  * M2;
//                    B2->Body.Velocity.Y = TangentY  * dpTan2  + NormalY  * M2;
//#endif
//                    return true;
//            }
//        }
//    }
//    return false;
//}







                 //
                 //List->Position.x +=Displacement * (Position.x - List->Position.x) / CollisionDist;
                 //List->Position.y +=Displacement * (Position.y - List->Position.y) / CollisionDist;
                 //List->Position.z +=Displacement * (Position.z - List->Position.z) / CollisionDist;
                 //Position.x -=Displacement * (Position.x - List->Position.x) / CollisionDist;
                 //Position.y -=Displacement * (Position.y - List->Position.y) / CollisionDist;
                 //Position.z -=Displacement * (Position.z - List->Position.z) / CollisionDist;