



When you use a vertex array pointer command with buffer objects, the data stored in the buffer object must meet alignment requirements as
determined by the type parameter. GLfloat data is typically aligned on 4-byte boundaries, for example. If your application calls 
glVertexPointer () with the type parameter set to GL_FLOAT, each float element stored in the corresponding buffer object must lie on a 
4-byte boundary.


glDrawElements ()— This command renders a single OpenGL primitive with vertices and vertex data specified by vertex array indices.

glDrawRangeElements ()— This optimized form of glDrawElements () restricts selected vertex data to a specified range of index values.

glMultiDrawElements ()— This command renders multiple OpenGL primitives of the same type. It, too, uses indices to obtain vertex data from vertex arrays.




2.3.3 Smooth and Flat Shading
To simulate a smooth surface, OpenGL interpolates vertex colors during rasterization. To simulate a flat or faceted surface, change the
 default shade model from GL_SMOOTH to GL_FLAT by calling glShadeModel ( GL_FLAT ).

void glShadeModel( GLenum mode );


To determine the color of a primitive in flat shade mode, OpenGL uses the color of the vertex that completes the primitive. For GL_POINTS, 
this is simply the color of the vertex. For all line primitives (GL_LINES, GL_LINE_STRIP, and GL_LINE_LOOP), this is the color of the second vertex in a line segment.


void glPolygonMode( GLenum face, GLenum mode );

Specifies the rendering style for filled primitives. mode is GL_POINT, GL_LINE, or GL_FILL; and face must be GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK to specify whether 
mode applies to front- or back-facing primitives, or both.




Set up your tripod and pointing the camera at the scene (viewing transformation). 
Arrange the scene to be photographed into the desired composition (modeling transformation). 
Choose a camera lens or adjust the zoom (projection transformation). 
Determine how large you want the final photograph to be - for example, you might want it enlarged (viewport transformation).

https://computergraphics.stackexchange.com/questions/5895/what-is-an-opengl-vao-in-a-nutshell
you MUST bind the VBO's under a VAO to get rendering output, if you just bind the VAO you won't get outpt. That's not true.
 You can bind dummy VAO without attached VBOs and still dispatch drawcall. – narthex Nov 20 '






 GLenum glCheckFramebufferStatus(	GLenum target);
 
 void glDrawArrays(	GLenum mode,
 	GLint first,
 	GLsizei count);


	C Specification
void glVertexAttribPointer(	GLuint index,
 	GLint size,
 	GLenum type,
 	GLboolean normalized,
 	GLsizei stride,
 	const GLvoid * pointer);
 

 

//		glViewport(0,0,640,480);
//GLuint Vert_Shader_Id = 0,
//	   Frag_Shader_Id = 0,
//	   Shader_Program_Id = 0;
 //
 //                 // GL_VERTEX_SHADER 0x8B31
////		Load_Shader(0x8B31, VERTEX_SHADER  , &Vert_Shader_Id);
//		          //GL_FRAGMENT_SHADER 0x8B30
//		Load_Shader(0x8B30,FRAGMENT_SHADER  , &Frag_Shader_Id);
//		Shader_Program_Id = glCreateProgram();
//		glAttachShader(Shader_Program_Id, Vert_Shader_Id);
//		glAttachShader(Shader_Program_Id, Frag_Shader_Id);
//		Print(Vert_Shader_Id);
//		Print(Frag_Shader_Id);
 //

//glClear(.0,.3,.8,1.0);


//https://www.3dgep.com/rendering-primitives-with-opengl/







// USE THIS TO MAKE A FPS Getter and Setters 
//glfwSwapBuffers(window);
//glfwSwapInterval(1);